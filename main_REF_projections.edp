// Compute projections of the reference solution in the semi-H1 norms on the Lagrange and CR P1 spaces
// run with   FreeFem++ main_REF_projections.edp  

string nameMPI = ""; //empty string for compatibility with init.idp
string bcType = "REF"; //to pass the right information to the name string in init.idp
string FEtype = "reference"; // empty string for compatibility with vffile.idp

int iproc=0, nbproc=1; //defined for compatibility with init.idp in the case of parallel computing

include "msfem_blocks/init.idp" // defines bilinear form, RHS, global P1 space Vh on the fine mesh
name = "REF"; // undo adaptations due to method settings
cout << "// Projections on coarse spaces" << endl;
ffLog << "// Projections on coarse spaces" << endl;

Vh uref; //the reference solution is a standard FE on the fine mesh
{
    string solname = "sol_" + name + parametersFine + ".txt";
    ifstream ff(solname);
    ff >> uref[];
}

fespace VHcont(TH,P1); //Lagrange P1 space
VHcont uHcont=0, vHcont;
fespace VHcr(TH,P1nc); //Crouzeix-Raviart P1 space
VHcr uHcr, vHcr;

macro semiH1(u,v) (dx(u)*dx(v) + dy(u)*dy(v)) //EOM

solve projectionCont(uHcont,vHcont) = int2d(TH)(semiH1(uHcont,vHcont)) //bilinear form associated to the projection
                                      + int1d(TH)(tgv*uHcont*vHcont) //boundary condition
                                      - int2d(Th,qft=qf1pT)(semiH1(uref,vHcont)); //note that both gradients are piecewise constant on the fine mesh
solve projectionCR(uHcr,vHcr) = int2d(TH)(semiH1(uHcr,vHcr)) //bilinear form associated to the projection
                                + int1d(TH,qfe=qf1pE)(tgv*uHcr*vHcr) //boundary condition imposed only in the centroid
                                - int2d(Th,qft=qf1pT)(semiH1(uref,vHcr)); //note that both gradients are piecewise constant on the fine mesh

if (plots) {
    if (plots==1) plot(uref,fill=1,value=1,wait=1, cmm="Reference solution");
    if (plots==1) plot(uHcont,fill=1,value=1,wait=1, cmm="Projection on Lagrange space");
    if (plots==1) plot(uHcr,fill=1,value=1,wait=1, cmm="Projection on Crouzeix-Raviart space");
}

// Compute norms of uref
resetNormsErrors //(re)set global error variables and norms to zero
nL1=int2d(Th)(abs(uref));
nL2=sqrt(int2d(Th)(uref*uref));
nH1=sqrt(int2d(Th)(uref*uref + dx(uref)*dx(uref) + dy(uref)*dy(uref)));

// Defining square domains for computations outside boundary layer/mesh elements at the outflow (olme)
VHcont olme = (x<Lx-Hx+hx/2. && y<Ly-Hy+hy/2.);
VH0 conditionMesh = (olme>0.9);
// macro for error computation with respect to a function approx
macro computeErrors(grid,exact,approx) {
    eL1  = int2d(grid)(abs(exact-approx));
    eOL1 = int2d(grid)(abs(exact-approx)*conditionMesh);
    eL2  = int2d(grid)((exact-approx)^2);
    eOL2 = int2d(grid)((exact-approx)^2*conditionMesh);
    eH1  = eL2  + int2d(grid)(  (dx(exact)-dx(approx))^2 + (dy(exact)-dy(approx))^2);
    eOH1 = eOL2 + int2d(grid)( ((dx(exact)-dx(approx))^2 + (dy(exact)-dy(approx))^2)*conditionMesh );
    eL2  = sqrt(eL2);
    eOL2 = sqrt(eOL2);
    eH1  = sqrt(eH1);
    eOH1 = sqrt(eOH1);
    try{ 
        erL1=eL1/nL1; erL2=eL2/nL2; erH1=eH1/nH1;
        erOL1=eOL1/nL1; erOL2=eOL2/nL2; erOH1=eOH1/nH1;
    }
    catch (...) {
        cout << "ERROR: norms are equal to zero. No relative errors are computed." << endl;
        ffLog << "ERROR: norms are equal to zero. No relative errors are computed." << endl;
    }
} 
//EOM
macro makedirectory(dirname) exec("mkdir -p " + dirname); //EOM

computeErrors(Th,uref,uHcont)
VH0 uB; //for compatibility with writing only
int coarseerrors=0;
{
    output = "sol_REF_Lin/"; // undo adaptations due to method settings
    makedirectory(output)
    VHcont uH; uH[]=uHcont[];
    postWriteResults(uH,uB,coarseerrors)
}
computeErrors(Th,uref,uHcr)
{
    output = "sol_REF_CR/"; // undo adaptations due to method settings
    makedirectory(output)
    VHcr uH; uH[]=uHcr[];
    postWriteResults(uH,uB,coarseerrors)
}
