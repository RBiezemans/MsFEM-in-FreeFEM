// tools.idp
//
// //         //          ////////  ////////  //         //
// ////      ///  //////  //        //        ////      ///
// // //    ////  //      //////    //////    // //    ////
// //  //  // //  //////  //        //        //  //  // //
// //   ////  //      //  //        //        //   ////  //
// //    //   //  //////  //        ////////  //    //   //
// Some (geometric) tools that are used when working with CR and oversampling methods and writing tools to provide output
//
// Variables not defined in this script /////////////////////////////////
// - ffLog -- (ofstream) writes execution log to "log_msfem.txt"
// - time -- (real) CPU time since last clocked
//
//
// Global variables declared in this script ////////////////////////////
// - (macro) loadRef[1] -- load reference solution to the argument FE function
// - (macro) loadCoarse[1] -- load the relevant projection of the reference solution to the argument FE function
// - (macro) residue[4] -- compute residue of the solution of a linear system and store in a predeclared variable
// - (macro) writeResidue[2] -- write a precomputed residue + message to the terminal and MsFEM log
// - (macro) printTime[1] -- print a message follows by the time since last clocking time (and clocks automatically)
// - (func)  consNormals[1] -- construct outward unit normals on the three edges of the argument passed
// - (macro) edgeIntegral[5] -- integration over a specific edge, one can choose to only integrate for specific labels
// - (macro) printIntegralsTri[2] -- write integrals of a function over all edges of the specified triangle to command line
// - (macro) ip[3] -- inner product between two components and a vector
// - (macro) ipcheck[2] -- compute the inner product of (x,y)-#2 and #1
// - (macro) resetNormErrors[unused] -- reset errors and norm variables on the current process to 0
////////////////////////////////////////////////////////////////////////


// Macros for loading external files
macro loadRef(target) {
    string refname = "sol_REF" + parametersFine + ".txt";
    ifstream ff(refname);
    ff>>uref[];
} // EOM

macro loadCoarse(target) {
    string refname = "sol_REF_" + bcType + "/solCoarse_REF" + parametersFine + "_n_" + n + ".txt";
    ifstream ff(refname);
    ff>>target[];
} // EOM


// Macro for residue computation of the resolution of linear systems
macro residue(mat,rhs,sol,residue) {
    real[int] res=mat*sol;
    res=res-rhs;
    real resNorm=sqrt(res'*res);
    real rhsNorm=sqrt(rhs'*rhs);
    residue=resNorm/rhsNorm;
} // EOM

// Macro for residue computation of the resolution of linear systems
macro writeResidue(residue,message) {
    cout << message << residue << endl;
	ffLog << message << residue << endl;
} // EOM

// Print a message follows by the time since last clocking time (and clocks automatically)
macro printTime(message) {
	real timeLapse = clock()-time;
	ffLog << message << timeLapse << "s" << endl;
	time=clock();
}
// EOM


// Saving the vertices of the ith triangle
macro saveVertexCoordinates(i,KK) {
    for(int kk=0; kk<3; kk++) {
        KK(kk,0) = TH[i][kk].x;
        KK(kk,1) = TH[i][kk].y;
    }
} // EOM


// Constructing normals
func real[int,int] consNormals(real[int,int] & pp) {
    // construct unit outward normals for a triangle of nodes pp (given with positive orientation)
    // if p_0 = (x_0, y_0) and p_1 = (x_1, y_1), 
    // then the normal opposite p_3 constructed here is parallel to (and points in the same direction as)
    //   n =  / (y_1 - y_0) \
    //        \-(x-1 - x_0) /

    real[int,int] normals(3,2); normals=0;
    for(int k=0; k<3; k++) {
        normals(k,0) =  ( pp((k+2)%3,1) - pp((k+1)%3,1) );
        normals(k,1) = -( pp((k+2)%3,0) - pp((k+1)%3,0) );
        real len = sqrt(normals(k,0)^2 + normals(k,1)^2);
        normals(k,:) = normals(k,:)/len;
    }
    return normals;
}


// Integrals over edges 
// In its use, we mostly adopt the following conventions:
// - label==-1  =>  boundary of global domain
// - label== 1  =>  only interior edges are considered
macro edgeIntegral(S,label,normS,edg,fnc) (int1d(S,label)( (ip(N.x,N.y,normS(edg,:))>0.99) *fnc))// EOM


// writing integrals of a function over all edges of K to command line
macro printIntegralsTri(K,uH) {
    cout << "Integrals on K: ";
    for (edg=0; edg<3; edg++) {
        real toprint = edgeIntegral(K,1,normS,edg,uH) + edgeIntegral(K,-1,normS,edg,uH);
        cout << toprint << "  ";
    }
    cout << endl;
} // EOM


// Related to inner products

//inner product of (u,v) with a vector (w[0],w[1])
macro ip(u,v,w) (u*w[0] + v*w[1])// EOM 


// Check if (x,y) - u2 points in the same direction as a normal vector u1
// A positive value means that this condition is indeed satisfied
macro ipcheck(u1, u2) ( u1[0]*(x-u2[0]) + u1[1]*(y-u2[1]) )// EOM


// Reset errors and norm variables on the current process to 0
macro resetNormsErrors() {
    nL1=0;   nL2=0;   nH1=0;   nMax=0;
    eL1=0;   eL2=0;   eH1=0;   eMax=0; 
    eML1=0;  eML2=0;  eMH1=0;  eMMax=0;
    eOL1=0;  eOL2=0;  eOH1=0;  eOMax=0;
    erL1=0;  erL2=0;  erH1=0;  erMax=0;
    erML1=0; erML2=0; erMH1=0; erMMax=0;
    erOL1=0; erOL2=0; erOH1=0; erOMax=0;
} // EOM


// Building the oversampling patch
macro buildOversamplingPatch(Kx,i,normS,S) {
    real[int,int] Sx(3,2); /* compute coordinates for the ideal oversampling patch by homothety */
    for(int kk=0; kk<3; kk++) {
        Sx(kk,0) = (osCoef)*(Kx(kk,0) - xb[][i]) + xb[][i];
        Sx(kk,1) = (osCoef)*(Kx(kk,1) - yb[][i]) + yb[][i];
    }

    if (timing) {
        cout << "Defining the ideal patch and its normals lasted " << clock()-time << " s" << endl;
        time=clock();
    }

    /* Construction of a patch-container C around S that is (much) smaller than Omega */
    int NxC = Nx/nx;
    int NyC = Ny/ny;

    real xCL = (floor(Sx(:,0).min/hx)-1)*hx; /* we take a small margin around the vertices of S as computed above */
    xCL = max(0.,xCL); /* ensure that the patch-container is a subset of the global domain */
    real xCR = (ceil(Sx(:,0).max/hx)+1)*hx;
    xCR=min(Lx, xCR);
    real yCL = (floor(Sx(:,1).min/hy)-1)*hy;
    yCL = max(0., yCL);
    real yCR = (ceil(Sx(:,1).max/hy)+1)*hy;
    yCR = min(Ly, yCR);

    real dxC = xCR - xCL;
    int dxCn = lrint(dxC/hx); /* integer closest to dxC/hx -- ensures that the mesh C defined below is compatible with Th */
    real dyC = yCR - yCL;
    int dyCn = lrint(dyC/hy);

    mesh C=square(dxCn, dyCn, [xCL + dxC*x, yCL + dyC*y], label=labs);
    fespace VC(C, P1);


    /* The the ideal oversampling patch is defined by 3 conditions: */
    /* Lying at the correct side of all three normals associated to S */
    normS=consNormals(Sx); /* normals to each of the boundaries of S */
    func cond1 = ( ipcheck(normS(2,:), Sx(0,:) ) < -1E-8 );
    func cond2 = ( ipcheck(normS(0,:), Sx(1,:) ) < -1E-8 );
    func cond3 = ( ipcheck(normS(1,:), Sx(2,:) ) < -1E-8 );

    VC patch;
    patch = cond1 && cond2 && cond3; 
    /* patch is a P1 representation of the conditions cond1, cond2 and cond3 being satisfied at the nodes of a fine mesh element 
     * S is obtained by requiring that they are all satisfied in all the vertices, i.e. patch > 2/3
     * patch is built on C rather than Th entirely to save time in costly function evaluations */
    if (debug) {
        VH0 psi=0;
        psi[][i]=1;
        plot(C, patch, psi, fill=1, cmm="Mesh element and oversampling patch", wait=1);
    }
    if (timing) {
        cout << "Building the indicator function for the (real) patch lasted " << clock()-time << " s" << endl;
        time=clock();
    }
    /* Build the real oversampling patch S */
    S = trunc(C, patch>0.9, split=1, label=1);
    /* fespace VS(S,P1); */

    if (debug) plot(C, S, cmm="Over-sampling fine mesh", wait=1);

    if (timing) {
        cout << "Building the patch lasted " << clock()-time << " s" << endl;
        time=clock();
    }
} // EOM