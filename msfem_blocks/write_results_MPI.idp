// write_results_MPI.idp
//
// //         //          ////////  ////////  //         //
// ////      ///  //////  //        //        ////      ///
// // //    ////  //      //////    //////    // //    ////
// //  //  // //  //////  //        //        //  //  // //
// //   ////  //      //  //        //        //   ////  //
// //    //   //  //////  //        ////////  //    //   //
// Writing solution and errors to external files (all writes appended)
//
//
// Compatible with parallel version only
//
//
// Variables not defined in this script /////////////////////////////////
// - ffLog -- (ofstream) writes execution log to "log_msfem.txt"
// - plots -- (int) indicates whether solutions should be plotted
// - iproc -- (int) local index of the current process
// - useB -- (int) indicates whether bubbles are to be used
// - vfname -- (string) description of (global and local) VF used
// - rhsDescription -- (string) description of the function fRHS
// - stabExpression -- (string) description of the formula used to determine the stabilization coefficient
// - uH -- (VH) P1 solution of the effective problem
// - uB -- (VH0) bubble coefficients computed from the effective problem
// - output -- (string) name of the directory (possibly to be created) where all output will be stored
// - parameters -- (string) parameters tuning the PDE and the MsFEM applied
// - name -- (string) abbreviation for  MsFEM underlying affine space
// - osCoef -- (real) the homothety coefficient chosen for the oversampling patch
// - uHh -- (Vh) reconstructed, fine-scale solution (but must be processed during element-per-element reconstruction)
// - uHhGl -- (Vh) global reconstructed solution, to be gathered by the main process
// - uref -- (Vh) reference solution
// - error -- (Vh) error between uHh and uref
// - (real[1]) eL1Gl, eL2Gl, eH1Gl, eMaxGl         -- errors on the entire domain
// - (real[1]) eML1Gl,  eML2Gl,  eMH1Gl,  eMMaxGl  -- errors OBL according to the definition of Madiot
// - (real[1]) eOL1Gl,  eOL2Gl,  eOH1Gl,  eOMaxGl  -- errors outside the mesh elements at the outflow
// - (real[1]) erL1Gl,  erL2Gl,  erH1Gl,  erMaxGl  -- relative errors on the entire domain
// - (real[1]) erML1Gl, erML2Gl, erMH1Gl, erMMaxGl -- relative errors OBL according to the definition of Madiot
// - (real[1]) erOL1Gl, erOL2Gl, erOH1Gl, erOMaxGl -- relative errors outside the mesh elements at the outflow
////////////////////////////////////////////////////////////////////////


// Saving and writing test results (main process only)
if (iproc==0) {
    // Computing norms of the reference solution
    real nL1=0, nL2=0, nH1=0, nMax=0;
    nL1=int2d(Th)(abs(uref));
    nL2=sqrt(int2d(Th)(uref*uref));
    nH1=sqrt(int2d(Th)(uref*uref + dx(uref)*dx(uref) + dy(uref)*dy(uref)));
    uref = abs(uref);
    nMax=uref[].max;
    string printNorms = "norms: " + nL1 + "  " + nL2 + "  " + nH1 + "  " + nMax;
    ffLog << printNorms;
    // Taking square roots, determining the relative errors
    eL2Gl[0]=sqrt(eL2Gl[0]);
    eML2Gl[0]=sqrt(eML2Gl[0]);
    eOL2Gl[0]=sqrt(eOL2Gl[0]);
    eH1Gl[0]=sqrt(eH1Gl[0]);
    eMH1Gl[0]=sqrt(eMH1Gl[0]);
    eOH1Gl[0]=sqrt(eOH1Gl[0]);
    try {
        erL1Gl[0]=eL1Gl[0]/nL1; erL2Gl[0]=eL2Gl[0]/nL2; erH1Gl[0]=eH1Gl[0]/nH1; erMaxGl[0]=eMaxGl[0]/nMax;
        erML1Gl[0]=eML1Gl[0]/nL1; erML2Gl[0]=eML2Gl[0]/nL2; erMH1Gl[0]=eMH1Gl[0]/nH1; erMMaxGl[0]=eMMaxGl[0]/nMax;
        erOL1Gl[0]=eOL1Gl[0]/nL1; erOL2Gl[0]=eOL2Gl[0]/nL2; erOH1Gl[0]=eOH1Gl[0]/nH1; erOMaxGl[0]=eOMaxGl[0]/nMax;
    } 
    catch (...) {
        cout << "ERROR: norms are equal to zero. No relative errors are computed." << endl;
        ffLog << "ERROR: norms are equal to zero. No relative errors are computed." << endl;
    }
    if (plots) {
        plot(uHh, wait=1, value=1, cmm="Reconstructed solution");
        plot(error, value=1, cmm="Error");
    }

    ffLog << "  Relative errors L1, L2, H1, max: " << erL1Gl[0] <<"   "<< erL2Gl[0] <<"   "<< erH1Gl[0] <<"   "<< erMaxGl[0] << endl;
    printTime("Reconstruction + error computation lasted ")

    {// Saving coarse scale solution
        string solCname = output+"solCoarse_" + name + parameters;
        solCname = solCname + ".txt";
        ffLog << "Writing solution in P1 basis to " << solCname << endl; 
        ofstream ff(solCname, append);
        ff << uH[] << endl;
        ff << endl;
    }
    if (treatB == "in_system") {// Saving bubble coefficients
        string solBname = output+"solCoarseB_" + name + parameters;
        solBname = solBname + ".txt";
        ffLog << "Writing coefficients for the bubble functions to " << solBname << endl; 
        ofstream ff(solBname, append);
        ff << uB[] << endl;
        ff << endl;
    }
    {// Saving reconstructed micro-scale solution
        string solname = output+"sol_" + name + parameters;
        solname = solname + ".txt";
        ffLog << "Writing reconstructed fine scale solution to " << solname << endl; 
        ofstream ff(solname, append);
        ff << uHhGl[] << endl;
        ff << endl;
    }

    {// Writing errors to an external file
        string errname = output + "err_" + vfname + "_"+ name + "_OS" + osCoef + ".txt";
        ffLog << "Writing errors to " << errname << endl;
        ofstream ff(errname, append);
        ff  << rhsDescription
            << endl
            << stabExpression
            << endl
            << "\t\t"
            << "n    " << n << "\t\t"
            << "N    " << Ndiscr << "\t\t"
            << "eps  " << eps << "\t\t"
            << "alp  " << alpha << "\t\t"
            << "cont " << cont << "\t\t"
            << "the  " << theta << "\t\t"
            << endl
            << "\t\t"
            << "useB     " << useB << "\t\t"
            << "testMS   " << testMS << "\t\t"
            << "strongD  " << strongDir << "\t\t"
            << "OScoef   " << osCoef << "\t\t"
            << endl
            << "\t\t"
            << "PeGlob   " << PeGlob << "\t\t"
            << "PeLoc    " << PeLoc  << "\t\t"
            << "PeFine   " << PeFine << "\t\t"
            << endl
            << "\t\t L1\t\t\t L2\t\t\t H1\t\t\t max\t\t L1rel\t\t L2rel\t\t H1rel\t\t maxrel\t\t"
            << endl;        
        
        ff  << "all \t"
            << eL1Gl[0]   <<"\t"<< eL2Gl[0]   <<"\t"<< eH1Gl[0]   <<"\t"<< eMaxGl[0]   <<"\t"
            << erL1Gl[0]  <<"\t"<< erL2Gl[0]  <<"\t"<< erH1Gl[0]  <<"\t"<< erMaxGl[0]
            << endl
            << "OBL \t"
            << eML1Gl[0]  <<"\t"<< eML2Gl[0]  <<"\t"<< eMH1Gl[0]  <<"\t"<< eMMaxGl[0]  <<"\t"
            << erML1Gl[0] <<"\t"<< erML2Gl[0] <<"\t"<< erMH1Gl[0] <<"\t"<< erMMaxGl[0]
            << endl
            << "OLME \t"
            << eOL1Gl[0]  <<"\t"<< eOL2Gl[0]  <<"\t"<< eOH1Gl[0]  <<"\t"<< eOMaxGl[0]  <<"\t"
            << erOL1Gl[0] <<"\t"<< erOL2Gl[0] <<"\t"<< erOH1Gl[0] <<"\t"<< erOMaxGl[0]
            << endl;

        ff<<endl;
    }

    cout << endl;
    ffLog << endl << endl; //end of MsFEM routine
}