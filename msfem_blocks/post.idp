// post.idp
//
// //         //          ////////  ////////  //         //
// ////      ///  //////  //        //        ////      ///
// // //    ////  //      //////    //////    // //    ////
// //  //  // //  //////  //        //        //  //  // //
// //   ////  //      //  //        //        //   ////  //
// //    //   //  //////  //        ////////  //    //   //
// Fine-scale reconstruction of the coarse solution, error computation
//
//
// Compatible with sequential version only
//
//
// Variables not defined in this script /////////////////////////////////
// - loadRef -- (macro[1]) load the reference solution from a ".txt" file
// - resetNormsErrors -- (macro[1]) reset norms and error variables for the current process to 0 
// - ffLog -- (ofstream) writes execution log to "log_msfem.txt"
// - plots -- (int) indicates whether solutions should be plotted
// - debug -- (int) provide helpful debugging output
// - TH -- (square) the coarse mesh of the global domain
// - VH0 -- (fespace) P0 space on TH
// - Vh -- (fespace) P1 space on the fine mesh
// - Lx, Ly -- (real) dimensions of the domain
// - phi -- (VH0) function on the coarse mesh that is used to partition the global domain
// - useB -- (int) indicates whether bubbles are to be used
// - useVcOnK -- (real[int]) indicates whether the correctors for constants are to be used on a specific coarse mesh element
// - rhsDescription -- (string) description of the function fRHS
// - uH -- (VH) P1 solution of the effective problem
// - uB -- (VH0) bubble coefficients computed from the effective problem
// - storeV[c/x/y] -- (real[int]) structures to store the DOF of numerical correctors
// - storeB -- (real[int]) structures to store the DOF of bubbles
// - widthMadiot -- (real) size of the boundary layer used by Madiot et al.
// - eL1, eL2, eH1, eMax -- (real) errors on the entire domain
// - eML1,  eML2,  eMH1,  eMMax -- (real) errors OBL according to the definition of Madiot
// - eOL1,  eOL2,  eOH1,  eOMax -- (real) errors outside the mesh elements at the outflow
// - erL1,  erL2,  erH1,  erMax -- (real) relative errors on the entire domain
// - erML1, erML2, erMH1, erMMax -- (real) relative errors OBL according to the definition of Madiot
// - erOL1, erOL2, erOH1, erOMax -- (real) relative errors outside the mesh elements at the outflow
//
//
// Global variables declared in this script ////////////////////////////
// - (VH0)  uH0 -- piecewise evaluation of uH at the barycentre
// - (VH0)  uHd[x/y] -- piecewise constant gradient of uH
// - (Vh)   uHh -- reconstructed, fine-scale solution (but must be processed during element-per-element reconstruction)
// - (Vh)   uref -- reference solution
// - (Vh)   error -- error between uHh and uref
////////////////////////////////////////////////////////////////////////


VH0 uH0=uH; //interpolation of uH at barycentres to facilitate local reconstructions
VH0 uHdx=dx(uH), uHdy=dy(uH); //interpolation of derivatives of uH (which in fact are piecewise constant)

Vh uHh=0, uref=0, error=0; //reconstructed solution, reference solution, error

try { //load reference solution on Th
    loadRef(uref)
}
catch (...) { //or compute the referece solution if the file is not found
    cout << "WARNING: No reference solution was found and it is recomputed" << endl;
    ffLog << "WARNING: No reference solution was found and it is recomputed" << endl;
    exec("FreeFem++ main_REF.edp -v 0 -ng");
    loadRef(uref)
}
if (plots) plot(uref,wait=1,value=1, cmm="Reference solution");

resetNormsErrors() //(re)set global error variables and norms to zero

// Reconstruction and error computation
// Error computation does not yet apply square roots, because these are to be taken once..
// ..all contributions are added at the end of the next for loop
for(int i=0; i<VH0.ndof; i++) {
    //build fine mesh of the current coarse mesh element K
    if (i%(2*n)==0) {
        cout <<"reconstruction on tri "<<i<<endl;
        // ffLog <<"reconstruction on tri "<<i<<endl;
    }
    phi[][i]=2;
    int[int] n2o;
    mesh K=trunc(Th,phi>1,split=1,new2old=n2o);
    fespace VK(K,P1);
    fespace VK0(K,P0);
    
    VK uHK;
    uHK=uH0[][i] + uHdx[][i]*(x-xb[][i]) + uHdy[][i]*(y-yb[][i]);
    //copying the coarse scale solution to the fine scale without interpolating it
    if (debug) plot(TH, uHK, wait=1, value=1, fill=1, cmm="Reconstruction: coarse solution");
    real[int] uHhK=uHK[]; //array currently representing the coarse solution on K
    if (useB) uHhK+=uB[][i]*storeB(i,:); //reconstructing the bubble function
    if (debug && useB) {uHK[]=uHhK; plot(TH, uHK, wait=1, value=1, fill=1, cmm="Reconstruction: coarse solution + B");}
    if (useVcOnK[i]) uHhK+=uH0[][i]*storeVc(i,:); //reconstructing the numerical corrector constants
    if (debug && useVcOnK[i]) {uHK[]=uHhK; plot(TH, uHK, wait=1, value=1, fill=1, cmm="Reconstruction: coarse solution + B + Vc");}
    uHhK+=uHdx[][i]*storeVx(i,:); //reconstructing the numerical corrector for the x-direction
    if (debug) {uHK[]=uHhK; plot(TH, uHK, wait=1, value=1, fill=1, cmm="Reconstruction: coarse solution + B + Vc + Vx");}
    uHhK+=uHdy[][i]*storeVy(i,:); //reconstructing the numerical corrector for the y-direction
    if (debug) {uHK[]=uHhK; plot(TH, uHK, wait=1, value=1, fill=1, cmm="Reconstruction: coarse solution + B + Vc + Vx + Vy");}

    int[int] R=restrict(VK, Vh, n2o);
    uHh[](R)=uHhK;

    VK errK=0;
    errK[] = uref[](R);
    errK[] = errK[]-uHhK;
    error[](R)=errK[];

    // Defining square domains for computations outside boundary layer/mesh elements at the outflow (olme)
    VK obl = (x<Lx-widthMadiot && y<Ly-widthMadiot);
    VK0 conditionMadiot = (obl>0.9);
    VK olme = (x<Lx-Hx+hx/2 && y<Ly-Hy+hy/2);
    VK0 conditionMesh = (olme>0.9);

    // Error computations on K
    eL1  += int2d(K)(abs(errK));
    eML1 += int2d(K)(abs(errK)*conditionMadiot);
    eOL1 += int2d(K)(abs(errK)*conditionMesh);
    real elocL2=0, elocML2=0, elocOL2=0; //local variables to temporarily store local L2 error contributions
    elocL2  = int2d(K)(errK*errK);
    elocML2 = int2d(K)(errK*errK*conditionMadiot);
    elocOL2 = int2d(K)(errK*errK*conditionMesh);
    eL2  += elocL2;
    eML2 += elocML2;
    eOL2 += elocOL2;
    eH1  += elocL2  + int2d(K)(  dx(errK)*dx(errK) + dy(errK)*dy(errK));
    eMH1 += elocML2 + int2d(K)( (dx(errK)*dx(errK) + dy(errK)*dy(errK))*conditionMadiot );
    eOH1 += elocOL2 + int2d(K)( (dx(errK)*dx(errK) + dy(errK)*dy(errK))*conditionMesh );
    errK = abs(errK);
    eMax  = max(eMax,errK[].max);
    VK errKK  = errK*conditionMadiot;
    eMMax = max(eMMax,errKK[].max);
    errKK  = errK*conditionMesh;
    eOMax = max(eOMax,errKK[].max);
    
    phi[][i]=0;
}
// Taking square roots, determining the relative errors
eL2=sqrt(eL2);
eML2=sqrt(eML2);
eOL2=sqrt(eOL2);
eH1=sqrt(eH1);
eMH1=sqrt(eMH1);
eOH1=sqrt(eOH1);

// Computing norms of the reference solution
nL1=int2d(Th)(abs(uref));
nL2=sqrt(int2d(Th)(uref*uref));
nH1=sqrt(int2d(Th)(uref*uref + dx(uref)*dx(uref) + dy(uref)*dy(uref)));
uref = abs(uref);
nMax=uref[].max;
{//for compatibility reasons, printNorms is kept a local variable
    string printNorms = "norms: " + nL1 + "  " + nL2 + "  " + nH1 + "  " + nMax;
    ffLog << printNorms;
}
try{ 
    erL1=eL1/nL1; erL2=eL2/nL2; erH1=eH1/nH1; erMax=eMax/nMax;
    erML1=eML1/nL1; erML2=eML2/nL2; erMH1=eMH1/nH1; erMMax=eMMax/nMax;
    erOL1=eOL1/nL1; erOL2=eOL2/nL2; erOH1=eOH1/nH1; erOMax=eOMax/nMax;
}
catch (...) {
    cout << "ERROR: norms are equal to zero. No relative errors are computed." << endl;
    ffLog << "ERROR: norms are equal to zero. No relative errors are computed." << endl;
}
if (plots) {
    plot(uHh, wait=1, value=1, cmm="Reconstructed solution");
    plot(error, value=1, cmm="Error");
}

ffLog << "  Relative errors L1, L2, H1, max: " << erL1 <<"   "<< erL2 <<"   "<< erH1 <<"   "<< erMax << endl;
printTime("Reconstruction + error computation lasted ")
