// offline_load_MPI.idp
//
// Read numerical correctors, bubble functions, and effective coefficients (if..
// ..available) from earlier computations. 
// Compute and save effective coefficients if they were not available for the method used
// Compute coefficients ifH[x/y]]TestMS related to the RHS of the PDE
// 
// Compatible only with parallelized version
//
// This file INCLUDES:
// - offline_effective_tensors_MPI.idp to compute the effective coefficients on a..
//   ..single coarse mesh element
// - offline_effective_tensors_MPI_reduce.idp to send all effective tensor..
//   ..computations to the main process
// - offline_save_effective_tensors.idp to save the effective coefficient
//
// This file USES:
// - basisDir -- name of the directory that will be used for reading the..
//               ..numerical correctors and bubbles
// - coeffDir -- name of the directory that will be used/created for reading/..
//               ..saving the effective coefficients associated to the MsFEM
//  storeV[x/y] -- the numerical correctors associated to the [x/y] direction relevant..
//                 ..to the current process are stored here
//  storeB -- the bubble functions associated to the [x/y] direction relevant to the..
//            ..current process are stored here
//  countOffline -- counter for the number of triangles associated to the current process
//  phi -- a P0 function on the coarse mesh that is used to partition the global domain
// - effective coefficients, the following P0 elements on the coarse mesh (possibly not all needed):
//   -- AHxx, AHxy, AHyx, AHyy, BHx, BHy, AHB, rHx, rHy, rH, lHx, lHy, fH, fB;
//   -- AHxxTestMS, AHxyTestMS, AHyxTestMS, AHyyTestMS;
//   -- rHxTestMS, rHyTestMS, fHxTestMS, fHyTestMS;
//   -- iAHxx, iAHxy, iAHyx, iAHyy, iBHx, iBHy, irHx, irHy, irH, ilHx, ilHy, ifH, ifB;
//   -- iAHxxTestMS, iAHxyTestMS, iAHyxTestMS, iAHyyTestMS;
//   -- irHxTestMS, irHyTestMS, ifHxTestMS, ifHyTestMS;


// Macro that provides the reading procedure from a file with name coeffDir+filename to the vector vec
macro readFile2Vec(filename,vec) {string matrixFile = coeffDir + filename; ifstream ffmat (matrixFile); ffmat >> vec;} // EOM

int computeCoeff=0; //variable to indicate whether or not the effective coefficients were found
    //this is indeed possible when the basis was computed but the coefficients were determined
    //with another type of test functions


// Try to open a file from the directory with effective coefficients
try {
    string matrixFile = coeffDir + "/AHxx.txt";
    ifstream ff(matrixFile);
    if (testMS==1) {
        string matrixFile = coeffDir + "/AHxxTestMS.txt";
        ifstream ff(matrixFile);
    }
    if (useB) {
        string matrixFile = coeffDir + "/rHx.txt";
        {ifstream ff(matrixFile);}
        if (testMS==1) {
            matrixFile = coeffDir + "/rHxTestMS.txt";
            ifstream ff(matrixFile);
        }
        if (treatB=="in_system") {
            matrixFile = coeffDir + "/lHx.txt";
            ifstream ff(matrixFile);
        }
    }
}
catch (...) {
    computeCoeff=1; // compute effective coefficients below if the correct version does not exist yet
}


// Load and store the basis for the current process in storeV[x/y] and storeB
// Compute effective coefficients per coarse mesh element if needed
for(int i=0; i<VH0.ndof; i++) {
if (iproc == i%nbproc) {
    if (i%(2*n)==0) {
        cout << "loading offline phase for tri " << i << endl;
        if (iproc==0) ffLog << "loading offline phase for tri " << i << endl;
    }
    phi[][i]=2;
    { //store numerical correctors associated to the x-direction
        string basisname = basisDir + "/tri_" + i + "_Vx" + ".txt";
        ifstream readVx(basisname);
        real[int] vec(ndofOffline);
        readVx >> vec;
        storeVx(countOffline,:) = vec;
    }
    { //store numerical correctors associated to the y-direction
        string basisname = basisDir + "/tri_" + i + "_Vy" + ".txt";
        ifstream readVy(basisname);
        real[int] vec(ndofOffline);
        readVy >> vec;
        storeVy(countOffline,:) = vec;
    }
    if (useB) { //store bubble functions for the FE space
        string basisname = basisDir + "/tri_" + i + "_B" + ".txt";
        ifstream readB(basisname);
        real[int] vec(ndofOffline);
        readB >> vec;
        storeB(countOffline,:) = vec;
    }

    // Define the numerical correctors on the current triangle in order to..
    // ..compute the necessary effective quantities
    mesh K=trunc(Th,phi>1,split=1); 
    fespace VK(K, P1);
    VK Vx, Vy, B;
    Vx[]=storeVx(countOffline,:);
    Vy[]=storeVy(countOffline,:);
    B[]=storeB(countOffline,:);
    
    // Compute effective coefficients (if needed)
    if (computeCoeff) {
        VK uHx=x-xb[][i], uHy=y-yb[][i];
        include "offline_effective_tensors_MPI.idp"
    } else {
    // Anything related to the right-hand side cannot be loaded from the previous..
    // ..offline phase and must be computed regardless of the availability of the..
    // ..coefficients
        if (useB) {
            if (treatB=="out_system") ifH[][i]=int2d(K)(fRHS)/K.measure;
            else ifB[][i]=int2d(K)(fRHS*B)/K.measure;
        }
        if (testMS) {
            ifHxTestMS[][i]=int2d(K)(fRHS*Vx)/K.measure;
            ifHyTestMS[][i]=int2d(K)(fRHS*Vy)/K.measure;
        }
    }

    phi[][i]=0;
    countOffline++;
}
}

//ffLog << "process " + iproc + " is done loading" + endl;

// Reduction of effective quantities to the main process
// Storage of effective quantities if newly computed
if (computeCoeff) {
    cout << "reduce effective coefficients to main process" << endl;
    include "offline_effective_tensors_MPI_reduce.idp"
    // store the effective coefficients for the coarse-scale model
    if (iproc==0) {
        //if nonexistent, the directory to store the effective coefficient was..
        //..created by the main file
        include "offline_save_effective_tensors.idp"
    }
}
else {
// The unavoidable reduction of quantities related to the RHS of the PDE
    if (treatB=="out_system") mpiReduce(ifH[], fH[], processor(0,comm), mpiSUM);
    else mpiReduce(ifB[], fB[], processor(0,comm), mpiSUM);
    if (testMS) {
        mpiReduce(ifHxTestMS[], fHxTestMS[], processor(0,comm), mpiSUM);
        mpiReduce(ifHyTestMS[], fHyTestMS[], processor(0,comm), mpiSUM);
    }
}
mpiBarrier(comm);


// Loading the effective coefficients when possible
// Only to be done by the main process
if (computeCoeff==0 && iproc==0) {
    // store the piecewise constant coefficients of the effective PDE
    cout << "loading effective coefficients" << endl;
    ffLog << "loading effective coefficients" << endl;
    readFile2Vec("/AHxx.txt", AHxx[])
    readFile2Vec("/AHyx.txt", AHyx[])
    readFile2Vec("/AHxy.txt", AHxy[])
    readFile2Vec("/AHyy.txt", AHyy[])
    readFile2Vec("/BHx.txt", BHx[])
    readFile2Vec("/BHy.txt", BHy[])
    if (testMS) {
        readFile2Vec("/AHxxTestMS.txt", AHxxTestMS[])
        readFile2Vec("/AHyxTestMS.txt", AHyxTestMS[])
        readFile2Vec("/AHxyTestMS.txt", AHxyTestMS[])
        readFile2Vec("/AHyyTestMS.txt", AHyyTestMS[])
    }
    if(useB) {
        readFile2Vec("/rH.txt",  rH[])
        readFile2Vec("/rHx.txt", rHx[])
        readFile2Vec("/rHy.txt", rHy[])
        if (treatB=="in_system") {
            readFile2Vec("/AHB.txt", AHB[])
            readFile2Vec("/lHx.txt", lHx[])
            readFile2Vec("/lHy.txt", lHy[])
        }
        if(testMS) {
            readFile2Vec("/rHxTestMS.txt", rHxTestMS[])
            readFile2Vec("/rHyTestMS.txt", rHyTestMS[])
        }
    }
}

mpiBarrier(comm);
if (iproc==0) printTime("Offline phase (computing + storing, measure by main process) lasted ")
