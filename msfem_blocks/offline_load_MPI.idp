// offline_load_MPI.idp
//
// Read numerical correctors, bubble functions, and effective coefficients (if..
// ..available) from earlier computations. 
// Compute and save effective coefficients if they were not available for the method used
// Compute coefficients ifH[x/y]]TestMS related to the RHS of the PDE
// 
// Compatible only with parallelized version
//
// This file INCLUDES:
// - offline_effective_tensors_MPI.idp to compute the effective coefficients on a..
//   ..single coarse mesh element
// - offline_effective_tensors_MPI_reduce.idp to send all effective tensor..
//   ..computations to the main process
// - offline_effective_tensors_save.idp to save the effective coefficient
//
// This file USES:
// - basisDir -- name of the directory that will be used for reading the..
//               ..numerical correctors and bubbles
// - coeffDir -- name of the directory that will be used/created for reading/..
//               ..saving the effective coefficients associated to the MsFEM
//  storeV[x/y] -- the numerical correctors associated to the [x/y] direction relevant..
//                 ..to the current process are stored here
//  storeB -- the bubble functions associated to the [x/y] direction relevant to the..
//            ..current process are stored here
//  countOffline -- counter for the number of triangles associated to the current process
//  phi -- a P0 function on the coarse mesh that is used to partition the global domain
// - effective coefficients, the following P0 elements on the coarse mesh (possibly not all needed):
//   -- AHxx, AHxy, AHyx, AHyy, BHx, BHy, rHx, rHy, rH, fH;
//   -- AHxxTestMS, AHxyTestMS, AHyxTestMS, AHyyTestMS, rHxTestMS, rHyTestMS, fHxTestMS, fHyTestMS;
//   -- iAHxx, iAHxy, iAHyx, iAHyy, iBHx, iBHy, irHx, irHy, irH, ifH;
//   -- iAHxxTestMS, iAHxyTestMS, iAHyxTestMS, iAHyyTestMS, irHxTestMS, irHyTestMS, ifHxTestMS, ifHyTestMS;


int computeCoeff=0; //variable to indicate whether or not the effective coefficients were found
    //this is indeed possible when the basis was computed but the coefficients were determined
    //with another type of test functions


// Try to open a file from the directory with effective coefficients
try {
    string matrixFile = coeffDir + "/AHxx.txt";
    ifstream ff(matrixFile);
}
catch (...) {
    computeCoeff=1; // compute effective coefficients below if the correct version does not exist yet
}


// Load and store the basis for the current process in storeV[x/y] and storeB
// Compute effective coefficients per coarse mesh element if needed
for(int i=0; i<VH0.ndof; i++) {
if (iproc == i%nbproc) {
    if (i%(2*n)==0) cout << "loading offline phase for tri " << i << endl;
    phi[][i]=2;
    { //store numerical correctors associated to the x-direction
        string basisname = basisDir + "/tri_" + i + "_Vx" + ".txt";
        ifstream readVx(basisname);
        real[int] vec(ndofOffline);
        readVx >> vec;
        storeVx(countOffline,:) = vec;
    }
    { //store numerical correctors associated to the y-direction
        string basisname = basisDir + "/tri_" + i + "_Vy" + ".txt";
        ifstream readVy(basisname);
        real[int] vec(ndofOffline);
        readVy >> vec;
        storeVy(countOffline,:) = vec;
    }
    if (useB) { //store bubble functions for the FE space
        string basisname = basisDir + "/tri_" + i + "_B" + ".txt";
        ifstream readB(basisname);
        real[int] vec(ndofOffline);
        readB >> vec;
        storeB(countOffline,:) = vec;
    }

    // Define the numerical correctors on the current triangle in order to..
    // ..compute the necessary effective quantities
    mesh K=trunc(Th,phi>1,split=1); 
    fespace VK(K, P1);
    VK Vx, Vy;
    Vx[]=storeVx(countOffline,:);
    Vy[]=storeVy(countOffline,:);
    
    // Compute effective coefficients (if needed)
    if (computeCoeff) {
        VK B; B[]=storeB(countOffline,:);
        VK uHx=x-xb[][i], uHy=y-yb[][i];
        include "offline_effective_tensors_MPI.idp"
    } else {
    // Anything related to the right-hand side cannot be loaded from the previous..
    // ..offline phase and must be computed regardless of the availability of the..
    // ..coefficients
        ifH[][i]=int2d(K)(fRHS)/K.measure;
        if (testMS) {
            ifHxTestMS[][i]=int2d(K)(fRHS*Vx)/K.measure;
            ifHyTestMS[][i]=int2d(K)(fRHS*Vy)/K.measure;
        }
    }

    phi[][i]=0;
    countOffline++;
}
}

cout << "process " + iproc + " is done loading" + endl;

// Reduction of effective quantities to the main process
// Storage of effective quantities if newly computed
if (computeCoeff) {
    cout << "reduce" << endl;
    include "offline_effective_tensors_MPI_reduce.idp"
    // store the effective coefficients for the coarse-scale model
    if (iproc==0) {
        //if nonexistent, the directory to store the effective coefficient was..
        //..created by the main file
        cout << "compute" << endl;
        include "offline_effective_tensors_save.idp"
    }
}
else {
// The unavoidable reduction of quantities related to the RHS of the PDE
    mpiReduce(ifH[], fH[], processor(0,comm), mpiSUM);
    mpiReduce(ifHxTestMS[], fHxTestMS[], processor(0,comm), mpiSUM);
    mpiReduce(ifHyTestMS[], fHyTestMS[], processor(0,comm), mpiSUM);
}
mpiBarrier(comm);


// Loading the effective coefficients when possible
// Only to be done by the main process
if (computeCoeff==0 && iproc==0) {
    // store the piecewise constant coefficients of the effective PDE
    cout << "loading effective coefficients" << endl;
    {
        string matrixFile = coeffDir + "/AHxx.txt";
        ifstream ffmat (matrixFile);
        ffmat >> AHxx[];
    }
    {
        string matrixFile = coeffDir + "/AHyx.txt";
        ifstream ffmat (matrixFile);
        ffmat >> AHyx[];
    }
    {
        string matrixFile = coeffDir + "/AHxy.txt";
        ifstream ffmat (matrixFile);
        ffmat >> AHxy[];
    }
    {
        string matrixFile = coeffDir + "/AHyy.txt";
        ifstream ffmat (matrixFile);
        ffmat >> AHyy[];
    }
    {
        string matrixFile = coeffDir + "/BHx.txt";
        ifstream ffmat (matrixFile);
        ffmat >> BHx[];
    }
    {
        string matrixFile = coeffDir + "/BHy.txt";
        ifstream ffmat (matrixFile);
        ffmat >> BHy[];
    }
    if(useB) {
        {
            string matrixFile = coeffDir + "/rH.txt";
            ifstream ffmat (matrixFile);
            ffmat >> rH[];
        }
        {
            string matrixFile = coeffDir + "/rHx.txt";
            ifstream ffmat (matrixFile);
            ffmat >> rHx[];
        }
        {
            string matrixFile = coeffDir + "/rHy.txt";
            ifstream ffmat (matrixFile);
            ffmat >> rHy[];
        }
    }
}
mpiBarrier(comm);
