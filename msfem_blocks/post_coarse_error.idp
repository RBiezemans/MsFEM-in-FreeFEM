// post_coarse_errors.idp
//
// //         //          ////////  ////////  //         //
// ////      ///  //////  //        //        ////      ///
// // //    ////  //      //////    //////    // //    ////
// //  //  // //  //////  //        //        //  //  // //
// //   ////  //      //  //        //        //   ////  //
// //    //   //  //////  //        ////////  //    //   //
// Fine-scale reconstruction of the coarse solution, error computation
// Writing solution and errors to external files (all writes appended)
//
//
// Compatible with sequential version only
//
//
// Variables not defined in this script /////////////////////////////////
// - VH -- (fespace) the relevant P1 space for the macroscopic problem
// - loadCoarse -- (macro[1]) load coarse projection of the reference solution
// - resetNormsErrors -- (macro[1]) reset norms and error variables for the current process to 0 
// - ffLog -- (ofstream) writes execution log to "log_msfem.txt"
// - plots -- (int) indicates whether solutions should be plotted
// - coarseerrors -- (string) controls what is saved in write_results[/_MPI].idp
// - TH -- (square) the coarse mesh of the global domain
// - VH0 -- (fespace) P0 space on TH
// - Lx, Ly -- (real) dimensions of the domain
// - uH -- (VH) P1 solution of the effective problem
// - widthMadiot -- (real) size of the boundary layer used by Madiot et al.
// - eL1, eL2, eH1, eMax -- (real) errors on the entire domain
// - eML1,  eML2,  eMH1,  eMMax -- (real) errors OBL according to the definition of Madiot
// - eOL1,  eOL2,  eOH1,  eOMax -- (real) errors outside the mesh elements at the outflow
// - erL1,  erL2,  erH1,  erMax -- (real) relative errors on the entire domain
// - erML1, erML2, erMH1, erMMax -- (real) relative errors OBL according to the definition of Madiot
// - erOL1, erOL2, erOH1, erOMax -- (real) relative errors outside the mesh elements at the outflow
//
//
// Global variables declared in this script ////////////////////////////
// - (VH)   urefH -- projection of the reference solution on VH
// - (VH)   errCoarse -- different between urefH and uH
////////////////////////////////////////////////////////////////////////


VH urefH=0; //projection of uref on VH

try { //load the relevant projection of the reference solution onto VH
    loadCoarse(urefH)
}
catch (...) { //or compute the projections first if they were not found
    cout << "WARNING: " + bcType + " projection of reference solution was not found and we compute it now" << endl;
    ffLog << "WARNING: " + bcType + " projection of reference solution was not found and we compute it now" << endl;
    exec("FreeFem++ main_REF_projections.edp -v 0 -ng");
    loadCoarse(urefH)
}
if (plots) plot(urefH,wait=1,value=1, cmm="Reference solution");

coarseerrors=1; //to set the correct behaviour of write_results[/_MPI].idp

resetNormsErrors() //(re)set global error variables and norms to zero

// Defining square domains for computations outside boundary layer/mesh elements at the outflow (olme)
VH errCoarse = urefH-uH;
VH obl = (x<Lx-widthMadiot && y<Ly-widthMadiot);
VH0 conditionMadiot = (obl>0.9);
VH olme = (x<Lx-Hx+hx/2 && y<Ly-Hy+hy/2);
VH0 conditionMesh = (olme>0.9);

// Error computations
eL1  = int2d(TH)(abs(errCoarse));
eML1 = int2d(TH)(abs(errCoarse)*conditionMadiot);
eOL1 = int2d(TH)(abs(errCoarse)*conditionMesh);
{
    real elocL2=0, elocML2=0, elocOL2=0; //local variables to temporarily store local L2 error contributions
    elocL2  = int2d(TH)(errCoarse*errCoarse);
    elocML2 = int2d(TH)(errCoarse*errCoarse*conditionMadiot);
    elocOL2 = int2d(TH)(errCoarse*errCoarse*conditionMesh);
    eL2  = elocL2;
    eML2 = elocML2;
    eOL2 = elocOL2;
    eH1  = elocL2  + int2d(TH)(  dx(errCoarse)*dx(errCoarse) + dy(errCoarse)*dy(errCoarse));
    eMH1 = elocML2 + int2d(TH)( (dx(errCoarse)*dx(errCoarse) + dy(errCoarse)*dy(errCoarse))*conditionMadiot );
    eOH1 = elocOL2 + int2d(TH)( (dx(errCoarse)*dx(errCoarse) + dy(errCoarse)*dy(errCoarse))*conditionMesh );
}
errCoarse = abs(errCoarse);
eMax  = errCoarse[].max;
VH errCoarseK  = errCoarse*conditionMadiot;
eMMax = errCoarseK[].max;
errCoarseK  = errCoarse*conditionMesh;
eOMax = errCoarseK[].max;
// Taking square roots, determining the relative errors
eL2=sqrt(eL2);
eML2=sqrt(eML2);
eOL2=sqrt(eOL2);
eH1=sqrt(eH1);
eMH1=sqrt(eMH1);
eOH1=sqrt(eOH1);

// Computing norms of the reference solution
nL1=int2d(TH)(abs(urefH));
nL2=sqrt(int2d(TH)(urefH*urefH));
nH1=sqrt(int2d(TH)(urefH*urefH + dx(urefH)*dx(urefH) + dy(urefH)*dy(urefH)));
urefH = abs(urefH);
nMax=urefH[].max;
{//for compatibility reasons, printNorms is kept a local variable
    string printNorms = "norms coarse projection: " + nL1 + "  " + nL2 + "  " + nH1 + "  " + nMax;
    ffLog << printNorms;
}
try{ 
    erL1=eL1/nL1; erL2=eL2/nL2; erH1=eH1/nH1; erMax=eMax/nMax;
    erML1=eML1/nL1; erML2=eML2/nL2; erMH1=eMH1/nH1; erMMax=eMMax/nMax;
    erOL1=eOL1/nL1; erOL2=eOL2/nL2; erOH1=eOH1/nH1; erOMax=eOMax/nMax;
}
catch (...) {
    cout << "ERROR: norms are equal to zero. No relative errors are computed." << endl;
    ffLog << "ERROR: norms are equal to zero. No relative errors are computed." << endl;
}

ffLog << "  Relative errors coarse space L1, L2, H1, max: " << erL1 <<"   "<< erL2 <<"   "<< erH1 <<"   "<< erMax << endl;
