// local_problems_CR.idp
//
// //         //          ////////  ////////  //         //
// ////      ///  //////  //        //        ////      ///
// // //    ////  //      //////    //////    // //    ////
// //  //  // //  //////  //        //        //  //  // //
// //   ////  //      //  //        //        //   ////  //
// //    //   //  //////  //        ////////  //    //   //
// Computation of numerical correctors and bubble functions on a single coarse mesh element for MsFEM-CR methods
//
//
// Scripts loaded ///////////////////////////////////////////////////////
// - offline_save_basis.idp 
//   -- save numerical correctors and bubble function
//
//
// Variables not defined in this script /////////////////////////////////
// This file USES:
// - debug -- (int) provide helpful debugging output
// - Th -- (square) the fine mesh of the global domain
// - TH -- (square) the coarse mesh of the global domain
// - phi -- (VH0) function on the coarse mesh that is used to partition the global domain
// - i -- (int) global index of the coarse mesh element to be treated
// - xb, yb -- (VH0) [x/y]-coordinate of the barycentres of the triangles of TH
// - useVcOnK -- (real[int]) indicates whether the correctors for constants are to be computed
// - useB -- (int) indicates whether bubbles are to be used
// - strongDir -- (int) specifies the type of boundary conditions on the global boundary for the numerical correctors
// - plotBubbles -- (int) indicates whether the user wishes to visualize V[c/x/y] and B
// - aBasis -- (macro) bilinear form for the local problems
// - consNormals -- (func[1]) constructs outward unit normals on the three edges of the argument passed
// - edgeIntegral -- (macro[5]) integration over a specific edge, one can choose to only integrate for specific labels
// - ip -- (macro[3]) inner product between two components and a vector
//  
//
// Global variables declared in this script ////////////////////////////
// - (real[int,int]) Kx -- Kx(j,[0/1]) is the [x/y]-coordinate of the j-th vertex of K
// - (mesh)    K -- fine mesh of the coarse mesh element indicated by phi
// - (fespace) VK -- P1 space on K
// - (VK)      Vc, Vx, Vy, B -- numerical correctors and bubble function on K
// - (VK)      uH[x/y]
////////////////////////////////////////////////////////////////////////


// Construct fine mesh, finite element space, normals
mesh K=trunc(Th,phi>1,split=1,label=1); //fine mesh of the coarse mesh element K indicated by phi
fespace VK(K,P1); //P1 finite element space on the triangle K

real[int,int] Kx(3,2); //save the coordinates of the vertices belonging to K
for(int kk=0; kk<3; kk++) {
    Kx(kk,0) = TH[i][kk].x;
    Kx(kk,1) = TH[i][kk].y;
}

real[int,int] normK(3,2); normK=consNormals(Kx); //normal vectors associated to the edges of K

// Select edges of K on which to impose Crouzeix-Raviart BC 
// (i.e. those not lying on the boundary of the global domain if strong Dirichlet conditions are chosen)
// We use that the global boundary was given the label -1, and the interior local boundaries the label 1
real[int] edges(3); edges=3; //to store those indices corresponding to the edges where CR conditions are imposed
int nedges=0; //number of edges where CR conditions will be imposed
if (strongDir) {
    for (int k=0; k<3; k++) {
        if (edgeIntegral(K,1,normK,k,1) > hx/10.) {
            //this condition tests positive iff the k-th edge does not lie on the boundary of the global domain
            edges[nedges]=k;
            nedges+=1;
        }
    }
} else {
    nedges=3;
    for (int k=0; k<nedges; k++) edges[k]=k;
}
if (debug) cout << "Edges for CR conditions: " << edges << endl;


// Construction of the local problems with Crouzeix-Raviart boundary conditions
// This is a sadlle point problem
varf pb(uh,vh)=int2d(K)(aBasis(uh,vh)); //variational formulation of local problems -- bilinear form -- LHS of the PDE of the saddle point problem
matrix A=pb(VK,VK); //linear system of the local problems -- matrix associated to the PDE
if (strongDir) { //add strong Dirichlet conditions to A if if S partially lies on the global boundary (with label 1)
    real testB = int1d(K,-1)(1.);
    if (testB > hx/2.) {
        if (strongDir==1) useVcOnK[i]=1; //we need Vc on K if strongDir==1 to correct the BC of the basis functions
        varf pdeDir(uh,vh) = int1d(K,-1)(uh*vh*tgv);
        matrix Adir = pdeDir(VK,VK);
        A = A+Adir;
        if (debug) cout << "Strong Dirichlet conditions are implemented on triangle " << i << endl;
    }
    else {
        if (debug) cout << "No strong Dirichlet conditions are implemented on triangle " << i << endl;
    }
} //all weak boundary conditions are handled by the linear constraints

int edg; //a dummy in intEdge representing integrations over each respective edge
varf intEdge(unused,vh) = edgeIntegral(K,1,normK,edg,vh) + edgeIntegral(K,-1,normK,edg,vh); //variational formulation of local problems -- bilinear form -- Lagrange multipliers/linear constraints
real[int,int] arrB(VK.ndof,nedges); //linear system of the local problems -- matrix associated to the Lagrange multipliers/linear constraints
for(int k=0; k<nedges; k++) { 
    //integrations over the edges of S that are to be given Crouzeix-Raviart boundary conditions
    edg=edges[k];
    real[int] Bedge = intEdge(0,VK);
    // real meas=edgeIntegral(K,1,normK,edg,1) + edgeIntegral(K,-1,normK,edg,1);
    // if (debug) {
    //     cout << "Measure of coarse element edge: " << meas << endl;
    // }
    // Bedge = Bedge/meas; //normalization is unnecessary since we are only imposing homogeneous constraints in the local problems
    arrB(:,k) = Bedge;
    if (debug) {
        VK test;
        test[] = arrB(:,k);
        plot(K, test, cmm="Edge selection on K for integration", fill=1, wait=1);
    }
}
matrix Bcr = arrB;

matrix CRmat = [[A,Bcr],
            [Bcr',0]]; //matrix for local saddle-point problem on K
set(CRmat, solver=UMFPACK);


// Variational formulations for strong Dirichlet conditions on the corrector to obtain homogeneous Dirichlet for the basis functions
// (will be used if strongDir==1; the formulation below then corresponds to penalization)
varf boundaryVx(unused,vh) = -int1d(K,-1)(tgv*(x-xb[][i])*vh);
varf boundaryVy(unused,vh) = -int1d(K,-1)(tgv*(y-yb[][i])*vh);
varf boundaryVc(unused,vh) = -int1d(K,-1)(tgv*vh);


// Complete definition and resolution of the linear systems for the fine-scale problems
VK Vc=0, Vx=0, Vy=0, B=0, uH=0, uHx=x-xb[][i], uHy=y-yb[][i];
// V[c/x/y] -- the numerical corrector associated to constants/the [x/y]-direction
// B -- bubble function for the MsFEM space associated to RHS = 1
// uH[x/y] -- the coordinate function in the [x/y]-direction that appears in the definition of the effective coefficients
// uH -- serves as a dummy in the variational form pbRHS to set the RHS for V[c/x/y] and B
real[int] F(VK.ndof+nedges), X(VK.ndof+nedges); F=0;
// X is used to store the solutions to the linear systems. These contain the multi-scale basis functions..
// ..and the Lagrange multipliers associated to the linear constraints
varf pbRHS(unused,vh)=-int2d(K)(aBasis(uH,vh)); //variational formulation of local problems -- linear form for the RHS of the numerical correctors
varf id(unused,vh) = int2d(K)(vh); //variational formulation of local problems -- linear form of the RHS for the bubble functions

// Resolution
if (useVcOnK[i]) {
    uH[]=1;  F(0:VK.ndof-1)=pbRHS(0,VK);  if (strongDir==1) F(0:VK.ndof-1)+=boundaryVc(0,VK);  X=CRmat^-1*F;   Vc[]=X;
    if (debug) {
        real testB = int1d(K,-1)(1.);
        if (testB>hx/2.) {residue(CRmat,F,X,"Corrector 0 was computed with residue ")}
    }
    //note that Vc[] and X are not of the same length; the Lagrange multipliers in X are automatically ignored
}

uH[]=uHx[];  F(0:VK.ndof-1)=pbRHS(0,VK);  if (strongDir==1) F(0:VK.ndof-1)+=boundaryVx(0,VK);  X=CRmat^-1*F;   Vx[]=X;
if (debug) residue(CRmat,F,X,"Corrector 1 was computed with residue ")

uH[]=uHy[];  F(0:VK.ndof-1)=pbRHS(0,VK);  if (strongDir==1) F(0:VK.ndof-1)+=boundaryVy(0,VK);  X=CRmat^-1*F;   Vy[]=X;
if (debug) residue(CRmat,F,X,"Corrector 2 was computed with residue ")

if (useB) {
    F(0:VK.ndof-1)=id(0,VK);    X=CRmat^-1*F;   B[]=X; //adapt if different Dirichlet conditions for bubbles are required
    if (debug) residue(CRmat,F,X,"Bubble was computed with residue ")
}

if (plotBubbles) {
    if (useVcOnK[i]) plot(TH, Vc, fill=1, value=1, wait=1, cmm="Bubble function for constants");
    plot(TH, Vx, fill=1, value=1, wait=1, cmm="Bubble function for x-direction");
    plot(TH, Vy, fill=1, value=1, wait=1, cmm="Bubble function for y-direction");
    if (useB) plot(TH, B, fill=1, value=1, wait=1, cmm="Bubble function for the RHS");
}

if (timing) {
    cout << "Solving for the basis functions lasted " << clock()-time << " s" << endl;
    time=clock();
}

include "offline_save_basis.idp" //store (externally) numerical correctors, bubble functions on K
