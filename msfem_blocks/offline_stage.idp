// offline_stage.idp
//
// //         //          ////////  ////////  //         //
// ////      ///  //////  //        //        ////      ///
// // //    ////  //      //////    //////    // //    ////
// //  //  // //  //////  //        //        //  //  // //
// //   ////  //      //  //        //        //   ////  //
// //    //   //  //////  //        ////////  //    //   //
// Macros to perform the offline stage of the MsFEM
//
////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////////////////
//////////                                                                           ////////// 
//////////   GENERIC MACROS                                                          //////////
//////////   to handle computation of effective coefficients and storage/loading     //////////
//////////                                                                           ////////// 
///////////////////////////////////////////////////////////////////////////////////////////////

// Save numerical correctors and bubble function to global data structures //
// i = index in storage infrastructure at which the just computed offline stage is stored
// Vc = computed numerical corrector related to constants
// V[x/y] = computed numerical corrector related to the [x/y]-direction
// B = computed bubble function
macro offlineSaveLocalComputations(i,Vc,Vx,Vy,B) {
    if (useVcOnK[i]) storeVc(i,:)=Vc[];
    storeVx(i,:)=Vx[]; storeVy(i,:)=Vy[]; 
    if (useB) storeB(i,:)=B[];
} // EOM

// Save numerical correctors and bubble function to external files //
// i = index of the coarse triangle whose local computations are stored in the coarse mesh TH
// Vc = computed numerical corrector related to constants
// V[x/y] = computed numerical corrector related to the [x/y]-direction
// B = computed bubble function
macro offlineExportLocalComputations(i,Vc,Vx,Vy,B) {    
    if (useVcOnK[i]) {
        string basisname = basisDir + "/tri_" + i + "_Vc" + ".txt";
        ofstream writeVc(basisname);
        writeVc << Vc[];
    }
    {
        string basisname = basisDir + "/tri_" + i + "_Vx" + ".txt";
        ofstream writeVx(basisname);
        writeVx << Vx[];
    }
    {
        string basisname = basisDir + "/tri_" + i + "_Vy" + ".txt";
        ofstream writeVy(basisname);
        writeVy << Vy[];
    }
    if(useB) {
        string basisname = basisDir + "/tri_" + i + "_B" + ".txt";
        ofstream writeB(basisname);
        writeB << B[];
    }
} // EOM

// Compute the effective coefficients for the right-hand side of the PDE based on pre-computed
//   numerical correctors V[c/x/y] and a bubble function B (which may be unused) for one mesh element //
// K = mesh of the triangle on which effective quantities are computed
// i = index of the coarse triangle whose local computations are stored in the coarse mesh TH
// Vc = computed numerical corrector related to constants
// V[x/y] = computed numerical corrector related to the [x/y]-direction
// B = computed bubble function
macro offlineEffectiveRhs(K,i,Vc,Vx,Vy,B) {
    if (useB) { 
        if (treatB=="out_system") ifH[][i]=int2d(K)(fRHS)/K.measure; /* average of fRHS per element */
        else ifB[][i]=int2d(K)(fRHS*B); /* no division by K.measure because this term does not appear in any effective varf */
    }

    if(testMS==1) {
        ifHxTestMS[][i]=int2d(K)(fRHS*Vx)/K.measure;
        ifHyTestMS[][i]=int2d(K)(fRHS*Vy)/K.measure;
        if (useVcOnK[i]) ifHTestMS[][i]=int2d(K)(fRHS*Vc)/K.measure;
        if (stabilization==1) {
            ifHxTestMSsupg[][i]=int2d(K)(rhssupg(Vx))/K.measure;
            ifHyTestMSsupg[][i]=int2d(K)(rhssupg(Vy))/K.measure;
            if (useVcOnK[i]) ifHTestMSsupg[][i]=int2d(K)(rhssupg(Vc))/K.measure;
        }
    }
} // EOM

// Reduce of RHS quantities for sequential MsFEM (copying to other variables) //
macro offlineEffectiveRhsReduce() {
    if (useB) { 
        if (treatB=="out_system") fH[]=ifH[];
        else fB[]=ifB[];
    }

    if(testMS==1) {
        fHxTestMS[]=ifHxTestMS[];
        fHyTestMS[]=ifHyTestMS[];
        if (useVc) fHTestMS[]=ifHTestMS[];
        if (stabilization==1) {
            fHxTestMSsupg[]=ifHxTestMSsupg[];
            fHyTestMSsupg[]=ifHyTestMSsupg[];
            if (useVc) fHTestMSsupg[]=ifHTestMSsupg[];
        }
    }
} // EOM

// Reduce of RHS quantities to the main process for parallelized MsFEM //
macro offlineEffectiveRhsReduceMPI() {
    if (useB) { 
        if (treatB=="out_system") mpiReduce(ifH[], fH[], processor(0,comm), mpiSUM);
        else mpiReduce(ifB[], fB[], processor(0,comm), mpiSUM);
    }

    if(testMS==1) {
        mpiReduce(ifHxTestMS[], fHxTestMS[], processor(0,comm), mpiSUM);
        mpiReduce(ifHyTestMS[], fHyTestMS[], processor(0,comm), mpiSUM);
        if (useVc) mpiReduce(ifHTestMS[], fHTestMS[], processor(0,comm), mpiSUM);
        if (stabilization==1) {
            mpiReduce(ifHxTestMSsupg[], fHxTestMSsupg[], processor(0,comm), mpiSUM);
            mpiReduce(ifHyTestMSsupg[], fHyTestMSsupg[], processor(0,comm), mpiSUM);
            if (useVc) mpiReduce(ifHTestMSsupg[], fHTestMSsupg[], processor(0,comm), mpiSUM);
        }
    }
} // EOM

// Compute the effective coefficients and effective right-hand side based on pre-computed
//   numerical correctors V[c/x/y] and a bubble function B (which may be unused) for one mesh element //
// K = mesh of the triangle on which effective quantities are computed
// i = index of the coarse triangle whose local computations are stored in the coarse mesh TH
// phi[0/x/y] = FE functions on K (that will be declared inside the macro)
// uH[x/y] = the centered coordinate function in the [x/y]-direction that appears in the definition of the effective coefficients
// Vc = computed numerical corrector related to constants
// V[x/y] = computed numerical corrector related to the [x/y]-direction
// B = computed bubble function
macro offlineEffectiveTensors(K,i,phi0,phix,phiy,uHx,uHy,Vc,Vx,Vy,B) {
    if (useVcOnK[i]) {
        phi0[]+=Vc[]; /* sums of affine functions and numerical correctors */
    }
    phix[]=uHx[]+Vx[]; 
    phiy[]=uHy[]+Vy[];

    iAHxx[][i]=int2d(K)(aComplete(phix,uHx))/K.measure;
    iAHyx[][i]=int2d(K)(aComplete(phix,uHy))/K.measure; 
    iAHxy[][i]=int2d(K)(aComplete(phiy,uHx))/K.measure; 
    iAHyy[][i]=int2d(K)(aComplete(phiy,uHy))/K.measure;
    /* pay attention, AH.. is not symmetric when a is not */

    iBHx[][i]=int2d(K)(aTest1(phix,1))/K.measure;
    iBHy[][i]=int2d(K)(aTest1(phiy,1))/K.measure;

    if (fullVF) {
        iBAHx[][i]=int2d(K)(aComplete(phi0,uHx))/K.measure;
        iBAHy[][i]=int2d(K)(aComplete(phi0,uHy))/K.measure;
        iMH[][i]=int2d(K)(aTest1(phi0,1))/K.measure;
    }

    if (useB) {
        irHx[][i]=int2d(K)(aComplete(B,uHx))/K.measure;
        irHy[][i]=int2d(K)(aComplete(B,uHy))/K.measure;
        irH[][i] =int2d(K)(aTest1(B,1))/K.measure;   
        if (treatB=="in_system") {
            iAHB[][i]=int2d(K)(aComplete(B,B)); 
            /* no division by K.measure because this term does not appear in any effective varf */
            ilHx[][i]=int2d(K)(aComplete(phix,B))/K.measure;
            ilHy[][i]=int2d(K)(aComplete(phiy,B))/K.measure;
            if (fullVF) ilH[][i]=int2d(K)(aComplete(phi0,B))/K.measure;
        }
    }

    if(testMS) {
        iAHxxTestMS[][i]=int2d(K)(aComplete(phix,Vx))/K.measure;
        iAHyxTestMS[][i]=int2d(K)(aComplete(phix,Vy))/K.measure; 
        iAHxyTestMS[][i]=int2d(K)(aComplete(phiy,Vx))/K.measure; 
        iAHyyTestMS[][i]=int2d(K)(aComplete(phiy,Vy))/K.measure;
        
        if (useVcOnK[i]) {
            iBHxTestMS[][i]=int2d(K)(aComplete(phix,Vc))/K.measure;
            iBHyTestMS[][i]=int2d(K)(aComplete(phiy,Vc))/K.measure;
        }

        if (fullVF) {
            iBAHxTestMS[][i]=int2d(K)(aComplete(phi0,Vx))/K.measure;
            iBAHyTestMS[][i]=int2d(K)(aComplete(phi0,Vy))/K.measure;
            if (useVcOnK[i]) iMHTestMS[][i]=int2d(K)(aComplete(phi0,Vc))/K.measure;
        }

        if (useB) {
            /* No "AHBTestMS" -- we always use the (multiscale) precomputed bubbles B */
            irHxTestMS[][i]=int2d(K)(aComplete(B,Vx))/K.measure;
            irHyTestMS[][i]=int2d(K)(aComplete(B,Vy))/K.measure;
            if (useVcOnK[i]) irHTestMS[][i] =int2d(K)(aComplete(B,Vc))/K.measure;   
            /* No "lH[x/y]TestMS" -- we always use the (multiscale) precomputed bubbles B */
        }
    }

    offlineEffectiveRhs(K,i,Vc,Vx,Vy,B)
} // EOM

// Reduce of effective tensors for sequential MsFEM (copying to other variables) //
macro offlineEffectiveTensorsReduce() {
    /* Retrieve the maximum residue of local computations over all processes */
    maxResOffline=imaxResOffline;
    if (bcType == "Lin" && osCoef > osThr) LINOSRes=iLINOSRes;

    /* Effective tensors */
    AHxx[]=iAHxx[];
    AHyx[]=iAHyx[];
    AHxy[]=iAHxy[];
    AHyy[]=iAHyy[];
    BHx[]=iBHx[];
    BHy[]=iBHy[];
    if (fullVF) {
        BAHx[]=iBAHx[];
        BAHy[]=iBAHy[];
        MH[]=iMH[];
    }
    if (useB) {
        rH[]=irH[];
        rHx[]=irHx[];
        rHy[]=irHy[];
        if (treatB=="in_system") {
            AHB[]=iAHB[];
            lHx[]=ilHx[];
            lHy[]=ilHy[];
            if (fullVF) lH[]=ilH[];
        } 
    }

    if (testMS) {
        AHxxTestMS[]=iAHxxTestMS[];
        AHyxTestMS[]=iAHyxTestMS[];
        AHxyTestMS[]=iAHxyTestMS[];
        AHyyTestMS[]=iAHyyTestMS[];
        if (useVc) {
            BHxTestMS[]=iBHxTestMS[];
            BHyTestMS[]=iBHyTestMS[];
        }
        if (fullVF) {
            BAHxTestMS[]=iBAHxTestMS[];
            BAHyTestMS[]=iBAHyTestMS[];
            if (useVc) MHTestMS[]=iMHTestMS[];
        }
        if(useB) {
            if (useVc) rHTestMS[]=irHTestMS[];
            rHxTestMS[]=irHxTestMS[];
            rHyTestMS[]=irHyTestMS[];
        }
    }

    /* Effective right-hand side terms */
    offlineEffectiveRhsReduce
} // EOM

// Reduce of RHS quantities to the main process for parallelized MsFEM //
macro offlineEffectiveTensorsReduceMPI() {
    /* Retrieve the maximum residue of local computations over all processes */
    mpiReduce(imaxResOffline, maxResOffline, processor(0,comm), mpiMAX);
    if (bcType == "Lin" && osCoef > osThr) mpiReduce(iLINOSRes, LINOSRes, processor(0,comm), mpiMAX);

    /* Effective tensors */
    mpiReduce(iAHxx[], AHxx[], processor(0,comm), mpiSUM);
    mpiReduce(iAHyx[], AHyx[], processor(0,comm), mpiSUM);
    mpiReduce(iAHxy[], AHxy[], processor(0,comm), mpiSUM);
    mpiReduce(iAHyy[], AHyy[], processor(0,comm), mpiSUM);
    mpiReduce(iBHx[], BHx[], processor(0,comm), mpiSUM);
    mpiReduce(iBHy[], BHy[], processor(0,comm), mpiSUM);
    if (fullVF) {
        mpiReduce(iBAHx[], BAHx[], processor(0,comm), mpiSUM);
        mpiReduce(iBAHy[], BAHy[], processor(0,comm), mpiSUM);
        mpiReduce(iMH[], MH[], processor(0,comm), mpiSUM);
    }
    if (useB) {
        mpiReduce(irH[], rH[], processor(0,comm), mpiSUM);
        mpiReduce(irHx[], rHx[], processor(0,comm), mpiSUM);
        mpiReduce(irHy[], rHy[], processor(0,comm), mpiSUM);
        if (treatB=="in_system") {
            mpiReduce(iAHB[], AHB[], processor(0,comm), mpiSUM);
            mpiReduce(ilHx[], lHx[], processor(0,comm), mpiSUM);
            mpiReduce(ilHy[], lHy[], processor(0,comm), mpiSUM);
            if (fullVF) mpiReduce(ilH[], lH[], processor(0,comm), mpiSUM);
        } 
    }

    if (testMS) {
        mpiReduce(iAHxxTestMS[], AHxxTestMS[], processor(0,comm), mpiSUM);
        mpiReduce(iAHyxTestMS[], AHyxTestMS[], processor(0,comm), mpiSUM);
        mpiReduce(iAHxyTestMS[], AHxyTestMS[], processor(0,comm), mpiSUM);
        mpiReduce(iAHyyTestMS[], AHyyTestMS[], processor(0,comm), mpiSUM);
        if (useVc) {
            mpiReduce(iBHxTestMS[], BHxTestMS[], processor(0,comm), mpiSUM);
            mpiReduce(iBHyTestMS[], BHyTestMS[], processor(0,comm), mpiSUM);
        }
        if (fullVF) {
            mpiReduce(iBAHxTestMS[], BAHxTestMS[], processor(0,comm), mpiSUM);
            mpiReduce(iBAHyTestMS[], BAHyTestMS[], processor(0,comm), mpiSUM);
            if (useVc) mpiReduce(iMHTestMS[], MHTestMS[], processor(0,comm), mpiSUM);
        }
        if(useB) {
            if (useVc) mpiReduce(irHTestMS[], rHTestMS[], processor(0,comm), mpiSUM);
            mpiReduce(irHxTestMS[], rHxTestMS[], processor(0,comm), mpiSUM);
            mpiReduce(irHyTestMS[], rHyTestMS[], processor(0,comm), mpiSUM);
        }
    }

    /* Effective right-hand side terms */
    offlineEffectiveRhsReduceMPI
} // EOM

// Save the effective coefficients of the PDE (can be called once all is reduced to the main process) //
macro offlineSaveEffectiveTensors() {    
    if (iproc==0) {/* the main process saves the effective coefficient (for the entire coarse mesh)*/
        /* Save residue information */
        ffRes << "The maximum residue for the numerical correctors is " << maxResOffline << endl;
        if (bcType == "Lin" && osCoef > osThr) ffRes << "The maximum residue for the LIN-OS 'DOF' option is " << LINOSRes << endl;
        ffRes << endl;

        { /* save Vc pattern for future loading of basis functions */
            string vecFile = basisDir + "/Vc_pattern.txt";
            ofstream ffvec (vecFile);
            ffvec << useVcOnK;
        }

        cout << "saving effective coefficients" << endl;
        ffLog << "saving effective coefficients" << endl;
        writeVec2File("/AHxx.txt", AHxx[])
        writeVec2File("/AHyx.txt", AHyx[])
        writeVec2File("/AHxy.txt", AHxy[])
        writeVec2File("/AHyy.txt", AHyy[])
        writeVec2File("/BHx.txt", BHx[])
        writeVec2File("/BHy.txt", BHy[])
        if (fullVF) {
            writeVec2File("/BAHx.txt", BAHx[])
            writeVec2File("/BAHy.txt", BAHy[])
            writeVec2File("/MH.txt", MH[])
        }
        if (useB) {
            writeVec2File("/rH.txt",  rH[])
            writeVec2File("/rHx.txt", rHx[])
            writeVec2File("/rHy.txt", rHy[])
            if (treatB=="in_system") {
                writeVec2File("/AHB.txt", AHB[])
                writeVec2File("/lHx.txt", lHx[])
                writeVec2File("/lHy.txt", lHy[])
                if (fullVF) writeVec2File("/lH.txt", lH[])
            } 
        }

        if (testMS) {
            writeVec2File("/AHxxTestMS.txt", AHxxTestMS[])
            writeVec2File("/AHyxTestMS.txt", AHyxTestMS[])
            writeVec2File("/AHxyTestMS.txt", AHxyTestMS[])
            writeVec2File("/AHyyTestMS.txt", AHyyTestMS[])
            if (useVc) {
                writeVec2File("/BHxTestMS.txt", BHxTestMS[])
                writeVec2File("/BHyTestMS.txt", BHyTestMS[])
            }
            if (fullVF) {
                writeVec2File("/BAHxTestMS.txt", BAHxTestMS[])
                writeVec2File("/BAHyTestMS.txt", BAHyTestMS[])
                if (useVc) writeVec2File("/MHTestMS.txt", MHTestMS[])
            }
            if(useB) {
                if (useVc) writeVec2File("/rHTestMS.txt",  rHTestMS[])
                writeVec2File("/rHxTestMS.txt", rHxTestMS[])
                writeVec2File("/rHyTestMS.txt", rHyTestMS[])
            }
        }
    }
} // EOM


///////////////////////////////////////////////////////////////////////////////////////////////
//////////                                                                           ////////// 
//////////   LOADING THE OFFLINE STAGE                                               //////////
//////////   numerical correctors (and possibly coefficients) have already been      //////////
//////////   computed and stored                                                     //////////
//////////                                                                           ////////// 
///////////////////////////////////////////////////////////////////////////////////////////////

macro offlineLoad() {
    int computeCoeff=0; 
        /* variable to indicate whether or not the effective coefficients were found
         * this is indeed possible when the basis was computed but the coefficients were determined
         * with another type of test functions */

    /* Try to open typical files from the directory with effective coefficients */
    try {
        string matrixFile = coeffDir + "/AHxx.txt";
        ifstream ff(matrixFile);
        if (fullVF) {
                matrixFile = coeffDir + "/BAHx.txt";  {ifstream ff(matrixFile);}
            }
        if (testMS==1) {
            string matrixFile = coeffDir + "/AHxxTestMS.txt";  {ifstream ff(matrixFile);}
        }
        if (useB) {
            string matrixFile = coeffDir + "/rHx.txt";  {ifstream ff(matrixFile);}
            if (testMS==1) {
                matrixFile = coeffDir + "/rHxTestMS.txt";  {ifstream ff(matrixFile);}
            }
            if (treatB=="in_system") {
                matrixFile = coeffDir + "/lHx.txt";  {ifstream ff(matrixFile);}
            }
        }
    }
    catch (...) {
        computeCoeff=1; /* compute effective coefficients below if the correct version does not exist yet */
    }

    /* Load and store the basis for the current process in storeV[c/x/y] and storeB
     * Compute effective coefficients per coarse mesh element if needed */
    { /* Load Vc pattern over all coarse mesh elements */
        string vecFile = basisDir + "/Vc_pattern.txt";
        ifstream ffvec (vecFile);
        ffvec >> useVcOnK;
    }
    int countOffline=0;
    for(int i=0; i<VH0.ndof; i++) {
        if (iproc == i%nbproc) {
            if (i%(2*n)==0) {
                cout << "loading offline phase for tri " << i << endl;
            }
            phi[][i]=2;
            if (useVcOnK[i]) { /* store numerical correctors associated to constants */
                string basisname = "/tri_" + i + "_Vc.txt";
                readBasis(basisname,storeVc(countOffline,:))
            }
            { /* store numerical correctors associated to the x-direction */
                string basisname = "/tri_" + i + "_Vx.txt";
                readBasis(basisname,storeVx(countOffline,:))
            }
            { /* store numerical correctors associated to the y-direction */
                string basisname = "/tri_" + i + "_Vy.txt";
                readBasis(basisname,storeVy(countOffline,:))
            }
            if (useB) { /* store bubble functions for the FE space */
                string basisname = "/tri_" + i + "_B.txt";
                readBasis(basisname,storeB(countOffline,:))
            }

            /* Define the numerical correctors on the current triangle in order to
             *   compute the necessary effective quantities */
            mesh K=trunc(Th,phi>1,split=1); 
            fespace VK(K, P1);
            VK Vc=0, Vx, Vy, B=0;
            if (useVcOnK[i]) Vc[]=storeVc(countOffline,:);
            Vx[]=storeVx(countOffline,:);
            Vy[]=storeVy(countOffline,:);
            if (useB) B[]=storeB(countOffline,:);
        
            /* Compute effective coefficients (if needed) */
            if (computeCoeff) {
                VK uHx=x-xb[][i], uHy=y-yb[][i];
                VK phi0=1, phix=0, phiy=0; 
                offlineEffectiveTensors(K,i,phi0,phix,phiy,uHx,uHy,Vc,Vx,Vy,B) /* also computes effective RHS quantities */
            } else {
            /* Anything related to the right-hand side cannot be loaded from the offline phase 
             * It must be computed regardless of the availability of the coefficients */
                offlineEffectiveRhs(K,i,Vc,Vx,Vy,B)
            }

            phi[][i]=0;
            countOffline++; /* countOffline coincides with the index i of the loop in the case of a single process */
        }
    }

    /* Reduction of effective quantities to the main process, saving effective quantities if newly computed */
    if (computeCoeff) {
        cout << "reduce effective coefficients to main process" << endl;
        if (nameMPI=="") {
            offlineEffectiveTensorsReduce
        } else {
            offlineEffectiveTensorsReduceMPI
        }
        if (iproc==0) {
            /* if nonexistent, the directory to store the effective coefficient was created by the main file */
            offlineSaveEffectiveTensors
        }
    }
    else {
    /* The unavoidable reduction of quantities related to the RHS of the PDE */
        if (nameMPI=="") {
            offlineEffectiveRhsReduce
        } else {
            offlineEffectiveRhsReduceMPI
        }
    }

    /* Loading the effective coefficients when possible
     * Only to be done by the main process */
    if (computeCoeff==0 && iproc==0) {
        /* store the piecewise constant coefficients of the effective PDE */
        cout << "loading effective coefficients" << endl;
        ffLog << "loading effective coefficients" << endl;
        readFile2Vec("/AHxx.txt", AHxx[])
        readFile2Vec("/AHyx.txt", AHyx[])
        readFile2Vec("/AHxy.txt", AHxy[])
        readFile2Vec("/AHyy.txt", AHyy[])
        readFile2Vec("/BHx.txt", BHx[])
        readFile2Vec("/BHy.txt", BHy[])
        if (fullVF) {
            readFile2Vec("/BAHx.txt", BAHx[])
            readFile2Vec("/BAHy.txt", BAHy[])
            readFile2Vec("/MH.txt", MH[])
        }
        if (useB) {
            readFile2Vec("/rH.txt",  rH[])
            readFile2Vec("/rHx.txt", rHx[])
            readFile2Vec("/rHy.txt", rHy[])
            if (treatB=="in_system") {
                readFile2Vec("/AHB.txt", AHB[])
                readFile2Vec("/lHx.txt", lHx[])
                readFile2Vec("/lHy.txt", lHy[])
                if (fullVF) readFile2Vec("/lH.txt", lH[])
            } 
        }

        if (testMS) {
            readFile2Vec("/AHxxTestMS.txt", AHxxTestMS[])
            readFile2Vec("/AHyxTestMS.txt", AHyxTestMS[])
            readFile2Vec("/AHxyTestMS.txt", AHxyTestMS[])
            readFile2Vec("/AHyyTestMS.txt", AHyyTestMS[])
            if (useVc) {
                readFile2Vec("/BHxTestMS.txt", BHxTestMS[])
                readFile2Vec("/BHyTestMS.txt", BHyTestMS[])
            }
            if (fullVF) {
                readFile2Vec("/BAHxTestMS.txt", BAHxTestMS[])
                readFile2Vec("/BAHyTestMS.txt", BAHyTestMS[])
                if (useVc) readFile2Vec("/MHTestMS.txt", MHTestMS[])
            }
            if(useB) {
                if (useVc) readFile2Vec("/rHTestMS.txt",  rHTestMS[])
                readFile2Vec("/rHxTestMS.txt", rHxTestMS[])
                readFile2Vec("/rHyTestMS.txt", rHyTestMS[])
            }
        }
    }

    if (iproc==0) printTime("Offline phase (computing + storing, measured by main process) lasted ")
} // EOM


///////////////////////////////////////////////////////////////////////////////////////////////
//////////                                                                           ////////// 
//////////   LOCAL PROBLEMS                                                          //////////
//////////   for MsFEM-LIN(-OS) and MsFEM-CR(-OS)                                    //////////
//////////   compute numerical correctors and effective coefficients                 //////////
//////////                                                                           ////////// 
///////////////////////////////////////////////////////////////////////////////////////////////

// Local computations for the MsFEM-LIN without oversampling //
// i = index of the coarse triangle whose local computations are stored in the coarse mesh TH
// countOffline = counter for the number of triangles treated by the current process
macro localProblemsLIN(i,countOffline) {
    phi[][i]=2;
    mesh K=trunc(Th,phi>1,split=1,label=1); /* fine mesh of the coarse mesh element K indicated by phi */
    fespace VK(K,P1); /* P1 finite element space on the triangle K */

    VK Vc=0, Vx=0, Vy=0, uH=0, B=0, uHx=x-xb[][i], uHy=y-yb[][i];
    /* V[c/x/y] -- the numerical corrector associated to constants/the [x/y]-direction
     * B -- bubble function for the MsFEM space associated to RHS = 1
     * uH[x/y] -- the centered coordinate function in the [x/y]-direction that appears in the definition of the effective coefficients
     * uH -- serves as a dummy in the variational form pb to set the RHS for V[c/x/y] and B */

    varf pb(uh,vh)=int2d(K)(aBasis(uh,vh)) + int1d(K)(tgv*uh*vh) /* variational formulation of local problems -- bilinear form */
                -int2d(K)(aBasis(uH,vh)); /* variational formulation of local problems -- linear form for the RHS of the numerical correctors */
    varf id(unused,vh) = int2d(K)(vh); /* variational formulation of local problems -- linear form of the RHS for the bubble functions */

    /* Definition and resolution of the linear systems for the fine-scale problems */
    matrix A=pb(VK,VK, solver=UMFPACK);
    real[int] F(VK.ndof);

    real locRes=0; /* residue in the computation of the numerical correctors */
    if (useVcOnK[i]) {
        uH[]=1;  F=pb(0,VK);  Vc[]=A^-1*F;
        residue(A,F,Vc[],locRes); /* store residue of the local problem to locRes */
        imaxResOffline=max(locRes,imaxResOffline);
    }
    uH[]=uHx[];  F=pb(0,VK);  Vx[]=A^-1*F;
    residue(A,F,Vx[],locRes); /* store residue of the local problem to locRes */
    imaxResOffline=max(locRes,imaxResOffline);
    uH[]=uHy[];  F=pb(0,VK);  Vy[]=A^-1*F;
    residue(A,F,Vy[],locRes); /* store residue of the local problem to locRes */
    imaxResOffline=max(locRes,imaxResOffline);
    if (useB) {
        F=id(0,VK);     B[]=A^-1*F;
        residue(A,F,B[],locRes); /* store residue of the local problem to locRes */
        imaxResOffline=max(locRes,imaxResOffline);
    }
    phi[][i]=0;

    if (plotBubbles) {
        if (useVcOnK[i]) plot(TH, Vc, fill=1, value=1, wait=1, cmm="Bubble function for constants");
        plot(TH, Vx, fill=1, value=1, wait=1, cmm="Bubble function for x-direction");
        plot(TH, Vy, fill=1, value=1, wait=1, cmm="Bubble function for y-direction");
        if (useB) plot(TH, B, fill=1, value=1, wait=1, cmm="Bubble function for the RHS");
    }

    offlineExportLocalComputations(i,Vc,Vx,Vy,B)
    offlineSaveLocalComputations(countOffline,Vc,Vx,Vy,B)
    VK phi0=1, phix=0, phiy=0; 
    offlineEffectiveTensors(K,i,phi0,phix,phiy,uHx,uHy,Vc,Vx,Vy,B)
} // EOM

// Local computations for the MsFEM-LIN with oversampling //
// i = index of the coarse triangle whose local computations are stored in the coarse mesh TH
// countOffline = counter for the number of triangles treated by the current process
macro localProblemsLINOS(i,countOffline) {
    /* Construction of the sampling patch S, the fine-scale P1 space VS on S
     * Defining the vertices of the ideal oversampling patch (possibly lying partially outside the global domain) */
    phi[][i]=2;
    real[int,int] Kx(3,2); 
    saveVertexCoordinates(i,Kx) /* save coordinates of the vertices belonging to K */
    real[int,int] normS(3,2); /* to save the normals to the sides of S = ideal oversampling patch */
    mesh S;
    buildOversamplingPatch(Kx,i,normS,S)
    fespace VS(S,P1);

    /* Construction of the actual coarse mesh element K inside of the patch */
    int[int] S2K;
    mesh K=trunc(S,phi>1,split=1,label=1,new2old=S2K); 
    fespace VK(K,P1);
    int[int] RS2K = restrict(VK,VS,S2K); /* array for the restriction of a function on S to K */

    VS VcS=0, VxS=0, VyS=0, BS=0, uH=0, uHxS=x-xb[][i], uHyS=y-yb[][i];
    /* V[c/x/y]S -- the numerical corrector on the patch associated to constants/the [x/y]-direction 
     * BS -- bubble function on the patch for the MsFEM space associated to RHS = 1 
     * uH[x/y]S -- the centered coordinate function in the [x/y]-direction on the patch that appears 
     *   in the definition of the effective coefficients
     * uH -- serves as a dummy in the variational form pb to set the RHS for V[c/x/y]S and B */

    varf pb(uh,vh)=int2d(S)(aBasis(uh,vh)) + int1d(S)(tgv*uh*vh) /* variational formulation of local problems -- bilinear form */
                -int2d(S)(aBasis(uH,vh)); /* variational formulation of local problems -- linear form for the RHS of the numerical correctors */
    varf id(unused,vh) = int2d(S)(vh);  /* variational formulation of local problems -- linear form of the RHS for the bubble functions */

    /* Definition and resolution of the linear systems for the fine-scale problems */
    matrix A=pb(VS,VS, solver=UMFPACK);
    real[int] F(VS.ndof);

    real locRes=0; /* residue in the computation of the numerical correctors */
    if (useVcOnK[i]) {
        uH[]=1;  F=pb(0,VS);  VcS[]=A^-1*F;
        residue(A,F,VcS[],locRes); /* store residue of the local problem to locRes */
        imaxResOffline=max(locRes,imaxResOffline);
    }
    uH[]=uHxS[];  F=pb(0,VS);  VxS[]=A^-1*F;
    residue(A,F,VxS[],locRes); /* store residue of the local problem to locRes */
    imaxResOffline=max(locRes,imaxResOffline);
    uH[]=uHyS[];  F=pb(0,VS);  VyS[]=A^-1*F;
    residue(A,F,VyS[],locRes); /* store residue of the local problem to locRes */
    imaxResOffline=max(locRes,imaxResOffline);
    if (useB) {
        F=id(0,VS);     BS[]=A^-1*F;
        residue(A,F,BS[],locRes); /* store residue of the local problem to locRes */
        imaxResOffline=max(locRes,imaxResOffline);
    }

    /* Restriction of the functions on the patch to the mesh element K */
    VK Vc=0, Vx=0, Vy=0, B=0, uHx=0, uHy=0; /* restrictions of functions from S to K */
    if (useVcOnK[i]) Vc[]=VcS[](RS2K);
    Vx[]=VxS[](RS2K);    Vy[]=VyS[](RS2K);  
    uHx[]=uHxS[](RS2K);  uHy[]=uHyS[](RS2K); 
    if(useB) B[]=BS[](RS2K);

    if (glue=="dof") {
        /* Impose continuity on the vertices of K if desired
         * This is done by adding the functions W[c/x/y] = [1/x/y]+V[c/x/y] */
        real ndofK=3;
        real[int,int] gval(ndofK,ndofK); /* matrix for W-values at the vertices */
        real[int] Vcval(ndofK), Vxval(ndofK), Vyval(ndofK), Bval(ndofK); /* values to be corrected of the patch functions */

        for(int i=0; i<ndofK; i++) {
            /* Evaluation of patch functions at the vertices: values to be corrected */
            Vxval(i)=-Vx(Kx(i,0),Kx(i,1));
            Vyval(i)=-Vy(Kx(i,0),Kx(i,1));
            if (useVcOnK[i]) Vcval(i)=-Vc(Kx(i,0),Kx(i,1));
            if (useB) Bval(i)=-B(Kx(i,0),Kx(i,1));
            /* Evaluation of 3 independent functions (W[c/x/y]) that solve the homogeneous PDE */
            gval(i,0)=Kx(i,0) - Vxval(i);
            gval(i,1)=Kx(i,1) - Vyval(i);
            gval(i,2)=1;
            if (useVcOnK[i]) gval(i,2)+=-Vcval(i);
        }
        matrix gmat=gval;
        set(gmat, solver=UMFPACK);
        real[int] c(ndofK);
        /* Definition of the correcting functions W[c/x/y] */
        VK Wc=1, Wx=x, Wy=y;
        Wx[]+=Vx[]; Wy[]+=Vy[];
        if (useVcOnK[i]) Wc[]+=Vc[];
        /* Correction at the vertices by the resolution of linear systems */
        /* Vc */
        if (useVcOnK[i]) {
            c=gmat^-1 * Vcval;
            residue(gmat,Vcval,c,locRes); /* store residue of local linear combinations */
            iLINOSRes=max(locRes,iLINOSRes);
            if (debug) writeResidue(locRes, "Residue for imposing continuity at the nodes (Vc): ")    
            Vc[]+=c[0]*Wx[];    Vc[]+=c[1]*Wy[];    Vc[]+=c[2]*Wc[];
        }
        /* Vx */
        c=gmat^-1 * Vxval;
        residue(gmat,Vxval,c,locRes); /* store residue of local linear combinations */
        iLINOSRes=max(locRes,iLINOSRes);
        if (debug) writeResidue(locRes, "Residue for imposing continuity at the nodes (Vx): ")
        Vx[]+=c[0]*Wx[];    Vx[]+=c[1]*Wy[];    Vx[]+=c[2]*Wc[];
        /* Vy */
        c=gmat^-1 * Vyval;
        residue(gmat,Vyval,c,locRes); /* store residue of local linear combinations */
        iLINOSRes=max(locRes,iLINOSRes);
        if (debug) writeResidue(locRes, "Residue for imposing continuity at the nodes (Vy): ")
        Vy[]+=c[0]*Wx[];    Vy[]+=c[1]*Wy[];    Vy[]+=c[2]*Wc[];
        /* B */
        if (useB) {
            c=gmat^-1 * Bval;
            residue(gmat,Bval,c,locRes); /* store residue of local linear combinations */
            iLINOSRes=max(locRes,iLINOSRes);
            if (debug) writeResidue(locRes, "Residue for imposing continuity at the nodes (B): ")
            B[]+=c[0]*Wx[];    B[]+=c[1]*Wy[];    B[]+=c[2]*Wc[];
        }
    } else {
        assert(glue=="restrict");
    }
    phi[][i]=0;

    if (plotBubbles) {
        if (useVcOnK[i]) plot(TH, Vc, fill=1, value=1, wait=1, cmm="Bubble function for constants");
        plot(TH, Vx, fill=1, value=1, wait=1, cmm="Bubble function for x-direction");
        plot(TH, Vy, fill=1, value=1, wait=1, cmm="Bubble function for y-direction");
        if (useB) plot(TH, B, fill=1, value=1, wait=1, cmm="Bubble function for the RHS");
    }

    offlineExportLocalComputations(i,Vc,Vx,Vy,B)
    offlineSaveLocalComputations(countOffline,Vc,Vx,Vy,B)
    VK phi0=1, phix=0, phiy=0; 
    offlineEffectiveTensors(K,i,phi0,phix,phiy,uHx,uHy,Vc,Vx,Vy,B)
} // EOM

// Local computations for the MsFEM-CR without oversampling //
// i = index of the coarse triangle whose local computations are stored in the coarse mesh TH
// countOffline = counter for the number of triangles treated by the current process
macro localProblemsCR(i,countOffline) {
    /* Construct fine mesh, finite element space, normals */
    phi[][i]=2;
    mesh K=trunc(Th,phi>1,split=1,label=1); /* fine mesh of the coarse mesh element K indicated by phi */
    fespace VK(K,P1); /* P1 finite element space on the triangle K */

    real[int,int] Kx(3,2); /* save the coordinates of the vertices belonging to K */
    saveVertexCoordinates(i,Kx) /* save coordinates of the vertices belonging to K */

    real[int,int] normK(3,2); normK=consNormals(Kx); /* normal vectors associated to the edges of K */

    /* Select edges of K on which to impose Crouzeix-Raviart BC
     * (i.e. those not lying on the boundary of the global domain if strong Dirichlet conditions are chosen)
     * We use that the global boundary was given the label -1, and the interior local boundaries the label 1 */
    real[int] edges(3); edges=3; /* to store those indices corresponding to the edges where CR conditions are imposed */
    int nedges=0; /* number of edges where CR conditions will be imposed */
    if (strongDir) {
        for (int k=0; k<3; k++) {
            if (edgeIntegral(K,1,normK,k,1) > hx/10.) {
                /* this condition tests positive iff the k-th edge does not lie on the boundary of the global domain */
                edges[nedges]=k;
                nedges+=1;
            }
        }
    } else {
        nedges=3;
        for (int k=0; k<nedges; k++) edges[k]=k;
    }
    if (debug) cout << "Edges for CR conditions: " << edges << endl;


    /* Construction of the local problems with Crouzeix-Raviart boundary conditions
     * This is a sadlle point problem */
    varf pb(uh,vh)=int2d(K)(aBasis(uh,vh)); /* variational formulation of local problems -- bilinear form 
                                             * -- LHS of the PDE of the saddle point problem */
    matrix A=pb(VK,VK); /* linear system of the local problems -- matrix associated to the PDE */
    if (strongDir) { /* add strong Dirichlet conditions to A if if S partially lies on the global boundary (with label 1) */
        real testB = int1d(K,-1)(1.);
        if (testB > hx/2.) {
            if (strongDir==1) useVcOnK[i]=1; /* we need Vc on K if strongDir==1 to correct the BC of the basis functions */
            varf pdeDir(uh,vh) = int1d(K,-1)(uh*vh*tgv);
            matrix Adir = pdeDir(VK,VK);
            A = A+Adir;
            if (debug) cout << "Strong Dirichlet conditions are implemented on triangle " << i << endl;
        }
        else {
            if (debug) cout << "No strong Dirichlet conditions are implemented on triangle " << i << endl;
        }
    } /* all weak boundary conditions are handled by the linear constraints */

    int edg; /* a dummy in intEdge representing integrations over each respective edge */
    varf intEdge(unused,vh) = edgeIntegral(K,1,normK,edg,vh) + edgeIntegral(K,-1,normK,edg,vh); 
        /* variational formulation of local problems -- bilinear form -- Lagrange multipliers/linear constraints */
    real[int,int] arrB(VK.ndof,nedges); /* linear system of the local problems -- matrix associated to the Lagrange multipliers/linear constraints */
    for(int k=0; k<nedges; k++) { 
        /* integrations over the edges of S that are to be given Crouzeix-Raviart boundary conditions */
        edg=edges[k];
        real[int] Bedge = intEdge(0,VK);
        /* the normalization below is unnecessary since we are only imposing homogeneous constraints in the local problems
         * real meas=edgeIntegral(K,1,normK,edg,1) + edgeIntegral(K,-1,normK,edg,1);
         * if (debug) {
         *     cout << "Measure of coarse element edge: " << meas << endl;
         * }
         * Bedge = Bedge/meas;  */
        arrB(:,k) = Bedge;
        if (debug) {
            VK test;
            test[] = arrB(:,k);
            plot(K, test, cmm="Edge selection on K for integration", fill=1, wait=1);
        }
    }
    matrix Bcr = arrB;

    matrix CRmat = [[A,Bcr],
                [Bcr',0]]; /* matrix for local saddle-point problem on K */
    set(CRmat, solver=UMFPACK);


    /* Variational formulations for strong Dirichlet conditions on the corrector to obtain homogeneous Dirichlet for the basis functions
     * (will be used if strongDir==1; the formulation below then corresponds to penalization) */
    varf boundaryVx(unused,vh) = -int1d(K,-1)(tgv*(x-xb[][i])*vh);
    varf boundaryVy(unused,vh) = -int1d(K,-1)(tgv*(y-yb[][i])*vh);
    varf boundaryVc(unused,vh) = -int1d(K,-1)(tgv*vh);


    /* Complete definition and resolution of the linear systems for the fine-scale problems */
    VK Vc=0, Vx=0, Vy=0, B=0, uH=0, uHx=x-xb[][i], uHy=y-yb[][i];
    /* V[c/x/y] -- the numerical corrector associated to constants/the [x/y]-direction
     * B -- bubble function for the MsFEM space associated to RHS = 1
     * uH[x/y] -- the coordinate function in the [x/y]-direction that appears in the definition of the effective coefficients
     * uH -- serves as a dummy in the variational form pbRHS to set the RHS for V[c/x/y] and B */
    real[int] F(VK.ndof+nedges), X(VK.ndof+nedges); F=0;
    /* X is used to store the solutions to the linear systems. These contain the multi-scale basis functions
     * and the Lagrange multipliers associated to the linear constraints */
    varf pbRHS(unused,vh)=-int2d(K)(aBasis(uH,vh)); /* variational formulation of local problems -- linear form for the RHS of the numerical correctors */
    varf id(unused,vh) = int2d(K)(vh); /* variational formulation of local problems -- linear form of the RHS for the bubble functions */

    /* Resolution */
    real locRes=0; /* residue in the computation of the numerical correctors */
    if (useVcOnK[i]) {
        uH[]=1;  F(0:VK.ndof-1)=pbRHS(0,VK);  if (strongDir==1) F(0:VK.ndof-1)+=boundaryVc(0,VK);  X=CRmat^-1*F;   Vc[]=X;
        residue(CRmat,F,X,locRes); /* store residue of the local problem to locRes */
        imaxResOffline=max(locRes,imaxResOffline);
        if (debug) {
            real testB = int1d(K,-1)(1.);
            if (testB>hx/2.) {writeResidue(locRes,"Corrector 0 was computed with residue ")}
        }
        /* note that Vc[] and X are not of the same length; the Lagrange multipliers in X are automatically ignored */
    }

    uH[]=uHx[];  F(0:VK.ndof-1)=pbRHS(0,VK);  if (strongDir==1) F(0:VK.ndof-1)+=boundaryVx(0,VK);  X=CRmat^-1*F;   Vx[]=X;
    residue(CRmat,F,X,locRes); /* store residue of the local problem to locRes */
    imaxResOffline=max(locRes,imaxResOffline);
    if (debug) writeResidue(locRes,"Corrector 1 was computed with residue ")

    uH[]=uHy[];  F(0:VK.ndof-1)=pbRHS(0,VK);  if (strongDir==1) F(0:VK.ndof-1)+=boundaryVy(0,VK);  X=CRmat^-1*F;   Vy[]=X;
    residue(CRmat,F,X,locRes); /* store residue of the local problem to locRes */
    imaxResOffline=max(locRes,imaxResOffline);
    if (debug) writeResidue(locRes,"Corrector 2 was computed with residue ")

    if (useB) {
        F(0:VK.ndof-1)=id(0,VK);    X=CRmat^-1*F;   B[]=X; /* adapt if different Dirichlet conditions for bubbles are required */
        residue(CRmat,F,X,locRes); /* store residue of the local problem to locRes */
        imaxResOffline=max(locRes,imaxResOffline);
        if (debug) writeResidue(locRes,"Bubble was computed with residue ")
    }
    phi[][i]=0;

    if (plotBubbles) {
        if (useVcOnK[i]) plot(TH, Vc, fill=1, value=1, wait=1, cmm="Bubble function for constants");
        plot(TH, Vx, fill=1, value=1, wait=1, cmm="Bubble function for x-direction");
        plot(TH, Vy, fill=1, value=1, wait=1, cmm="Bubble function for y-direction");
        if (useB) plot(TH, B, fill=1, value=1, wait=1, cmm="Bubble function for the RHS");
    }

    if (timing) {
        cout << "Solving for the basis functions lasted " << clock()-time << " s" << endl;
        time=clock();
    }

    offlineExportLocalComputations(i,Vc,Vx,Vy,B)
    offlineSaveLocalComputations(countOffline,Vc,Vx,Vy,B)
    VK phi0=1, phix=0, phiy=0; 
    offlineEffectiveTensors(K,i,phi0,phix,phiy,uHx,uHy,Vc,Vx,Vy,B)

} // EOM

// Local computations for the MsFEM-CR with oversampling //
// i = index of the coarse triangle whose local computations are stored in the coarse mesh TH
// countOffline = counter for the number of triangles treated by the current process
macro localProblemsCROS(i,countOffline) {
    real[int,int] Kx(3,2); 
    saveVertexCoordinates(i,Kx) /* save coordinates of the vertices belonging to K */
    real[int,int] normS(3,2); /* to save the normals to the sides of S = ideal oversampling patch */
    mesh S;
    buildOversamplingPatch(Kx,i,normS,S)
    fespace VS(S,P1);

    /* Construction of the actual coarse mesh element K inside of the patch */
    phi[][i]=2;
    int[int] S2K;
    mesh K=trunc(S,phi>1,split=1,label=1,new2old=S2K); 
    fespace VK(K,P1);
    int[int] RS2K = restrict(VK,VS,S2K); /* array for the restriction of a function on S to K */

    if (timing) {
        cout << "Building the fine mesh locally lasted " << clock()-time << " s" << endl;
        time=clock();
    }

    /* Select edges of S on which to impose Crouzeix-Raviart BC
     * (i.e. those not lying on the boundary of the global domain if strong Dirichlet conditions are chosen)
     * We use that the global boundary was given the label -1, and the interior local boundaries the label 1 */
    real[int] edges(3); edges=3; /* to store those indices corresponding to the edges where CR conditions are imposed */
    int nedges=0; /* number of edges where CR conditions will be imposed */
    if (strongDir) {
        for (int k=0; k<3; k++) {
            if (edgeIntegral(K,1,normS,k,1) > hx/10.) {
                /* this condition tests positive iff the k-th edge does not lie on the boundary of the global domain */
                edges[nedges]=k;
                nedges+=1;
            }
        }
    } else {
        nedges=3;
        for (int k=0; k<nedges; k++) edges[k]=k;
    }

    if (debug) cout << "Edges for CR conditions: " << edges << endl;
    if (timing) {
        cout << "Selecting the edges lasted " << clock()-time << " s" << endl;
        time=clock();
    }

    /* Construction of the local problems with Crouzeix-Raviart boundary conditions
     * This is a sadlle point problem */
    varf pdeLoc(uh,vh) = int2d(S)(aBasis(uh,vh)); /* variational formulation of local problems -- bilinear form -- LHS of the PDE on S of the saddle point problem */
    matrix A = pdeLoc(VS,VS); /* linear system of the local problems -- matrix associated to the PDE */
    if (strongDir) { /* add strong Dirichlet conditions to A if S partially lies on the global boundary (with label 1) */
        real testB = int1d(S,-1)(1.);
        if (testB > hx/2.) {
            if (strongDir==1) useVcOnK[i]=1; /* we need Vc on K if strongDir==1 to correct the BC of the basis functions */
            varf pdeDir(uh,vh) = int1d(S,-1)(uh*vh*tgv);
            matrix Adir = pdeDir(VS,VS);
            A = A+Adir;
            if (debug) cout << "Strong Dirichlet conditions are implemented on triangle " << i << endl;
        }
        else {
            if (debug) cout << "No strong Dirichlet conditions are implemented on triangle " << i << endl;
        }
    } /* all weak boundary conditions are handled by the linear constraints */

    int edg; /* a dummy in linF1 and linF2 representing integrations over each respective edge */
    varf linF1(unused,vh) = edgeIntegral(S,1,normS,edg,vh) + edgeIntegral(S,-1,normS,edg,vh);
    real[int,int] arrB1(VS.ndof,nedges); /* Lagrange multiplier matrix (linear form 1, for integrations over the boundary of S) */
    for(int k=0; k<nedges; k++) {
        /* integrations over the edges of S that are to be given Crouzeix-Raviart boundary conditions */
        edg=edges[k];
        real[int] Bedge = linF1(0,VS);
        /* real meas=edgeIntegral(S,1,normS,edg,1) + edgeIntegral(S,-1,normS,edg,1);
         * if (debug) {
         *     cout << "Measure of patch edge: " << meas << endl;
         * }
         * Bedge = Bedge/meas; 
         * normalization is unnecessary since we are only imposing homogeneous constraints in the local problems */
        arrB1(:,k) = Bedge;
        if (debug) {
            VS test;
            test[] = arrB1(:,k);
            plot(TH, S, test, cmm="Edge selection on S for integration", fill=1, wait=1);
        }
    }

    matrix B1 = arrB1;
    matrix B2;
    if (glue=="restrict") B2 = arrB1;
    varf linF2(unused,vh) = edgeIntegral(K,1,normS,edg,vh) + edgeIntegral(K,-1,normS,edg,vh);
    if (glue=="dof") {
        real[int,int] arrB2(VS.ndof,nedges); /* constraint matrix (linear form 2, for integrations over the boundary of K) */
        for(int k=0; k<nedges; k++) {
            /* integrations over the edges of K that correspond to Crouzeix-Raviart boundary conditions */
            edg=edges[k];
            real[int] Bedge = linF2(0,VS);
            /* real meas=edgeIntegral(S,1,normS,edg,1) + edgeIntegral(S,-1,normS,edg,1);
             * Bedge = Bedge/meas; 
             * normalization is unnecessary since we are only imposing homogeneous constraints in the local problems */
            arrB2(:,k) = Bedge;
            if (debug) {
                VS test;
                test[] = arrB2(:,k);
                plot(S, test, cmm="Edge selection on K for integration", fill=1, wait=1);
            }
        }
        B2 = arrB2;
    }

    matrix CRmat = [[A,B1],
                    [B2',0]]; /* matrix for local saddle-point problem on S */
    set(CRmat, solver=UMFPACK);

    if (timing) {
        cout << "Building the matrix lasted " << clock()-time << " s" << endl;
        time=clock();
    }

    /* Variational formulations for strong Dirichlet conditions on the corrector to obtain homogeneous Dirichlet for the basis functions
     * (will be used if strongDir==1; the formulation below then corresponds to penalization) */
    varf boundaryVx(unused,vh) = -int1d(S,-1)(tgv*(x-xb[][i])*vh);
    varf boundaryVy(unused,vh) = -int1d(S,-1)(tgv*(y-yb[][i])*vh);
    varf boundaryVc(unused,vh) = -int1d(S,-1)(tgv*vh);

    /* Complete definition and resolution of the linear systems for the fine-scale problems */
    VS VcS=0, VxS=0, VyS=0, BS=0, uH=0, uHxS=x-xb[][i], uHyS=y-yb[][i];
    /* V[c/x/y]S -- the numerical corrector on the patch associated to constants/the [x/y]-direction
     * BS -- bubble function on the patch for the MsFEM space associated to RHS = 1
     * uH[x/y] -- the coordinate function in the [x/y]-direction that appears in the definition of the effective coefficients
     * uH -- serves as a dummy in the variational form pbRHS to set the RHS for V[c/x/y]S and BS */
    real[int] F(VS.ndof+nedges), X(VS.ndof+nedges); F=0;
    /* X is used to store the solutions to the linear systems. These contain the multi-scale basis functions
     * and the Lagrange multipliers associated to the linear constraints */
    varf pbRHS(unused,vh)=-int2d(S)(aBasis(uH,vh));  /* variational formulation of local problems -- linear form for the RHS of the numerical correctors */
    varf id(unused,vh) = int2d(K)(vh); /* variational formulation of local problems -- linear form of the RHS for the bubble functions */

    /* Resolution: */
    real locRes=0; /* residue in the computation of the numerical correctors */
    if(useVcOnK[i]) {
        uH[]=1;  F(0:VS.ndof-1)=pbRHS(0,VS);  if (strongDir==1) F(0:VS.ndof-1)+=boundaryVc(0,VS);  X=CRmat^-1*F;   VcS[]=X;
        residue(CRmat,F,X,locRes); /* store residue of the local problem to locRes */
        imaxResOffline=max(locRes,imaxResOffline);
        if (debug) {
            real testB = int1d(S,-1)(1.);
            if (testB>hx/2.) {
                    writeResidue(locRes,"Corrector 0 was computed with residue ")
                }
        }
        if (debug) printIntegralsTri(K,normS,VcS)
        /* note that Vc[] and X are not of the same length; the Lagrange multipliers in X are automatically ignored */
    }

    uH[]=uHxS[];  F(0:VS.ndof-1)=pbRHS(0,VS);  if (strongDir==1) F(0:VS.ndof-1)+=boundaryVx(0,VS);  X=CRmat^-1*F;   VxS[]=X;
    residue(CRmat,F,X,locRes); /* store residue of the local problem to locRes */
    imaxResOffline=max(locRes,imaxResOffline);
    if (debug) writeResidue(locRes,"Corrector 1 was computed with residue ")
    if (debug) printIntegralsTri(K,normS,VxS)

    uH[]=uHyS[];  F(0:VS.ndof-1)=pbRHS(0,VS);  if (strongDir==1) F(0:VS.ndof-1)+=boundaryVy(0,VS);  X=CRmat^-1*F;   VyS[]=X;
    residue(CRmat,F,X,locRes); /* store residue of the local problem to locRes */
    imaxResOffline=max(locRes,imaxResOffline);
    if (debug) writeResidue(locRes,"Corrector 2 was computed with residue ")
    if (debug) printIntegralsTri(K,normS,VyS)
    phi[][i]=0;

    if (useB) {
        F(0:VS.ndof-1)=id(0,VS);    X=CRmat^-1*F;   BS[]=X; /* adapt if different Dirichlet conditions for bubbles are required */
        residue(CRmat,F,X,locRes); /* store residue of the local problem to locRes */
        imaxResOffline=max(locRes,imaxResOffline);
        if (debug) writeResidue(locRes,"Bubble was computed with residue ")
        if (debug) printIntegralsTri(K,normS,BS)
    }

    if (timing) {
        cout << "Solving for the basis functions lasted " << clock()-time << " s" << endl;
        time=clock();
    }

    /* Restriction of the functions on the patch to the mesh element K */
    VK Vc=0, Vx=0, Vy=0, B=0, uHx=0, uHy=0;
    /* V[c/x/y] -- is the numerical corrector associated to the .-direction
     * B -- bubble function for the MsFEM space associated to RHS = 1 */
    if (useVcOnK[i]) Vc[]=VcS[](RS2K);
    Vx[]=VxS[](RS2K);    Vy[]=VyS[](RS2K);  
    uHx[]=uHxS[](RS2K);  uHy[]=uHyS[](RS2K); 
    if(useB) B[]=BS[](RS2K);

    if (plotBubbles) {
        if (useVcOnK[i]) plot(TH, Vc, fill=1, value=1, wait=1, cmm="Bubble function for constants");
        plot(TH, Vx, fill=1, value=1, wait=1, cmm="Bubble function for x-direction");
        plot(TH, Vy, fill=1, value=1, wait=1, cmm="Bubble function for y-direction");
        if (useB) plot(TH, B, fill=1, value=1, wait=1, cmm="Bubble function for the RHS");
    }

    offlineExportLocalComputations(i,Vc,Vx,Vy,B)
    offlineSaveLocalComputations(countOffline,Vc,Vx,Vy,B)
    VK phi0=1, phix=0, phiy=0; 
    offlineEffectiveTensors(K,i,phi0,phix,phiy,uHx,uHy,Vc,Vx,Vy,B)
} // EOM