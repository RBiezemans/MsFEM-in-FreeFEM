// offline_effective_RHS.idp
//
// //         //          ////////  ////////  //         //
// ////      ///  //////  //        //        ////      ///
// // //    ////  //      //////    //////    // //    ////
// //  //  // //  //////  //        //        //  //  // //
// //   ////  //      //  //        //        //   ////  //
// //    //   //  //////  //        ////////  //    //   //
// Computation for the effective terms that appear in the RHS for some methods
//
//
// Compatible only with sequential version
//
//
// Variables not defined in this script /////////////////////////////////
// - K -- (mesh) coarse mesh element that is treated
// - i -- (int) global index of the coarse mesh element to be treated
// - fH -- (VH0) is to hold the average of the RHS function on each mesh element if treatB == out_system
// - fB -- (VH0) is to hold the integral of the RHS function on each mesh element against the respective bubble function if treatB == in_system
// - fH[/x/y]TestMS[/supg] -- (VH0) effective terms
// - V[c/x/y] -- (VK) numerical correctors on K
// - B -- (VK) bubble function on K
// - useVcOnK -- (real[int]) indicates whether the correctors for constants are to be used on a specific coarse mesh element
// - useB -- (int) indicates whether bubbles are to be used
// - testMS -- (int) indicates whether test functions are multiscale or P1
// - stabilization -- (int) indicates whether or not stabilization terms are used
////////////////////////////////////////////////////////////////////////



if (useB) { 
    if (treatB=="out_system") fH[][i]=int2d(K)(fRHS)/K.measure; //average of fRHS per element
    else fB[][i]=int2d(K)(fRHS*B); //no division by K.measure because this term does not appear in any effective varf
}

if(testMS==1) {
    fHxTestMS[][i]=int2d(K)(fRHS*Vx)/K.measure;
    fHyTestMS[][i]=int2d(K)(fRHS*Vy)/K.measure;
    if (useVcOnK[i]) fHTestMS[][i]=int2d(K)(fRHS*Vc)/K.measure;
    if (stabilization==1) {
        fHxTestMSsupg[][i]=int2d(K)(rhssupg(Vx))/K.measure;
        fHyTestMSsupg[][i]=int2d(K)(rhssupg(Vy))/K.measure;
        if (useVcOnK[i]) fHTestMSsupg[][i]=int2d(K)(rhssupg(Vc))/K.measure;
    }
}
